# JS高级知识和ES6+

## JS基础总结深入

### 数据类型

数据类型的分类：

- 基本（值）数据类型
  - String Number Boolean Null Undefined
- 对象（引用）数据类型
  - Object

Function：特殊的对象，可以执行。
Array：特殊的对象，数值下标，内部数据有序。

数据类型的判断：

- `typeof`
  - 可以判断数值、字符串、undefined、布尔值、function
  - 不能判断null和object
  - 不能判断object和array
  - 使用typeof检查`array`会返回`object`而不是`array`
  - 检查数组必须使用`instanceof`
- `instanceof`判断对象的具体类型，`instance`的含义是实例
- `===` 可以判断undefined、null
  
数量类型判断不要使用`==`，因为它有可能会做数据类型转换。

`表达式()` 代表这个表达式是函数，函数可以执行，对象不可以执行。
数组是有序的数据，通过下标来操作。

#### 实例和类型

- 实例是实例对象，类型是类型对象。
- 构造函数：通过new关键字调用的函数称为构造函数，构造函数是专门用来创建对象的函数。
- 构造函数即是类型对象，一个构造函数称为一个类。
- 通过同一类函数创建的对象，称为一类对象。
- 一类的对象就称为该类的实例。
- 构造函数习惯首字母大写
- 只有new的时候，才能确定是构造函数。
- 普通函数直接调用，构造函数需要使用new关键字调用`var per = new Penson;`

#### null和undefined

null和undefined的区别：

- `undefined`代表定义了未赋值
- `null`代表定义了也赋值了，只是赋的值为null

什么时候赋值为null；

- 初始赋值为`nul`l时，代表将要赋值为对象。
  - `var b = null`代表b将要赋值为称对象
  - `b = [1,2,3]`确定对象并赋值。
- 最后赋值为`null`，表示释放对象内存。
  - `b = null`让b指向的对象称为垃圾对象，被垃圾回收器回收。

### 数据、内存、变量

- 数据：存储在内存中的信息，本质是010101····
  - 在计算机中，不同的数据所需的存储空间不同，为了充分利用存储空间，就定义了不同的数据类型
  - JS将数据分为基本数据类型和引用（对象）数据类型两大类
  - 数据可传递、可运算
- 内存：内存条通电后产生的可存储数据的临时空间
  - 内存分为栈内存和堆内存
  - 基本数据类型的值，直接保存在**栈内存**中。
  - 对象数据类型的值保存在**堆内存**中的，而对象的引用（即变量）是保存在**栈内存中**的。
- 变量：程序向内存申请的一块可以存储数据的空间
  - JS中，所有的变量都保存在**栈内存**中的。
  - 变量需要的声明和赋值
  - 变量名：查找对应的内存
  - 变量值：内存中保存的数据

内存的产生和死亡：

- 内存条是电子元器件组成的电路板
- 内存的产生：内存条->通电->产生内存空间—>存储数据->处理数据
- 内存的死亡：断电->内存空间消失，数据同时消失

对象是变量吗？当然不是，对象是数据类型，变量是内存的标识，通过变量才可以使用内存，不可以直接说对象是变量。

`obj.name`其中的`.`的含义是沿着地址找到内容，只有地址数据才能`.`

内存是临时存储空间，硬盘是永久存储空间。内存速度快，硬盘慢。

`var a = xxx`

- xxx是基本数据类型，保存的就是这个数据
- xxx是引用数据类型，保存的就是对象的地址值
- xxx是变量，保存的是xxx的内存内容，可能是基本数据，也可能是地址值。

#### 形参和实参

- 声明形参就相当于在函数内部声明了对应的变量，但是并不赋值。
- 调用函数时传递的参数，实参将会传递给函数中对应的形参。
  
JS在调用函数时传递变量参数，是值传递还是引用传递？

- 理解1：都是值传递，不过这个值可能是基本值可能是地址值
- 理解2：可以是值传递，也可能是引用传递（地址值）

#### 内存处理

内存的生命周期

- 分配小内存空间，得到它的使用权
- 存储数据，可以反复操作
- 释放小内存空间

释放内存

- 局部变量：函数执行完，自动释放
- 对象：称为垃圾对象===》垃圾回收器回收

### 对象

什么是对象？

- 对象是多个数据的封装体
- 一个对象代表现实中的一个事物

对象的作用？

- 使用对象可以统一管理多个数据

对象的组成？

- 对象中有属性和方法，方法是一种特别的属性
- 属性由属性名（字符串）和属性值（任意数据类型）组成
- 属性值是函数时，就称这个属性为方法

如何访问对象中的内部数据？

- `对象名.属性名`
- `对象名["属性名"] 这种方式更通用

什么时候必须使用`[]`的方式？

- 属性名包含特殊字符(- 空格)
- 变量名不确定

### 函数

什么是函数？

- 实现特定功能的多条语句的封装体
- 只有函数是可以执行的

为什么使用函数？

- 提高代码复用
- 便于阅读交流

如何定义函数？

- 函数声明 `var function fun(){}`
- 函数表达式 `var fun = function(){}`

如何调用（执行）函数？

- 直接调用`fun()`
- 通过对象调用`obj.fun()`
- new调用 `new fun()`
- 临时将一个函数作为指定对象的方法调用`fun.call/apply(obj)`

#### 回调函数

什么是回调函数？

- 你定义的
- 你没有调用
- 但最终函数执行了

常见的回调函数？

- DOM事件的回调函数
- 定时器回调函数
- Ajax请求回调函数
- 生命周期回调函数

#### IIFE

IIFE；Immediately-Invoked Function Expression（立即调用的函数表达式），也称为`匿名函数自调用`

使用IIFE的好处：

- 不必为函数命名，避免了污染全局变量
- IFE 内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量。

#### this

- `fun()`this是window
- `obj.fun()`this是obj
- `var p = new test()`this是新建的对象p
- `p.call(obj)`this是obj

#### 关于js分号问题

加不加分号是编码风格问题，只有自己喜不喜欢。

在下面情况下不加分号：

- 小括号开头的前一条语句（匿名函数自调用）
- 中方括号开头的前一条语句

Vue.js框架的代码全部不带分号

## 函数高级

### 原型与原型链

#### 原型(prototype)

- 每个函数对象都有一个prototype属性，该属性默认对应一个`{}`(空对象)，称为原型对象。这个空对象`{}`是Object的实例对象。
- 原型对象都有一个constructor属性，指向函数对象。

空对象表示没有我们自己添加的属性。

给原型对象添加属性（方法）===》实例对象可以访问。

#### 显式原型和隐式原型

- 每个函数对象都有一个prototype属性，称为显式原型属性，默认指向`{}`空实例对象。
- 每个实例对象都有一个__proto__属性，称为隐式原型属性。
- 构造函数对象的显示原型===实例对象的隐式原型
- Function是new Function()产生的
- Object也是new Function()产生的
- 所有函数的__proto__都是一样的

- 函数的prototype属性：在定义函数时自动添加的，默认值是Object空对象。
- 对象的__proto__属性：创建对象时自动添加的，默认值为构造函数的prototype属性值。
- 不要直接操作隐式原型(ES6之前)。

#### 原型链

- 访问一个对象的属性，先在自身寻找，找到返回
- 找不到沿着__proto__这条链找，找到返回
- 最终没找到，返回undefined
- 原型链别名隐式原型链

作用：查找对象属性（方法）

#### 原型的继承

- 构造函数的实例对象自动拥有构造函数原型对象的属性（方法）
- 原理：原型链

1. 所有函数的显示原型指向的对象是空Object实例对象(Object不满足)
   - `Object.prototype instanceof Object`//false
2. 所有函数都是Function的实例，包括Function本身和Object
   - `Function.__proto===Function.prototype`
3. Object的原型对象是原型链的尽头
   - `object.prototype.__proto__`//null

#### instanceof

- A instanceof B
- 如果B函数的显式原型对象在A对象的原型链上，返回true，否则返回false。

### 执行上下文与执行上下文栈

#### 变量提升与函数提升

- 变量声明提升：通过var声明的变量，在定义语句前就可以访问到，值为undefined
- 函数声明提升：通过function声明的函数，在之前就可以直接调用，值为函数对象
- 先执行变量提升再提示函数提升。

#### 执行上下文

代码分为全局代码和局部（函数）代码

全局执行上下文：

1. 在执行全局代码前，将window确定为全局执行上下文
2. 对全局数据进行预处理
   - `var`定义的全局变量==》undefined，添加为window的属性
   - `function`声明的全局函数==》赋值为fun，添加为window的方法
   - `this`赋值为window
3. 开始执行全局代码

函数执行上下文：

1. 在调用函数时，准备执行函数体前，创建对应的函数的执行上下文对象（虚拟的对象）
2. 对局部数据进行处理
   - 形参变量==》赋值（实参）==》添加为执行上下文的属性
   - arguments==》赋值（实参列表）==》添加为执行上下文的属性
   - var
   - function
   - this==>赋值（调用函数的对象）
3. 开始执行局部代码

总结：n+1个执行上下文，n代表调用函数的次数，1代表window

#### 执行上下文栈

- 栈：后进先出
- 在执行上下文前，JS会创建一个栈来管理所有的执行上下文对象。
- 在全局执行上下文（window）确定后，加入栈中（压栈）
- 函数执行上下文确定后，加入栈中压栈
- 当前函数执行完后，将栈顶的对象移除（出栈）
- 当前所有的代码执行完后，栈中还剩下window

#### 递归调用

递归调用的特点

- 在函数内部调用自己
- 一般会有return返回值退出循环

### 作用域与作用域链

作用域是一个代码段所在的区域，是静态的（相对于执行上下文），在编写编码时就确定了。

分类：

- 全局作用域
- 函数作用域
- 没有块作用域（ES6）之前

作用：

- 隔离变量，不同的作用域下同名变量不会有冲突

总结：n+1个作用域，n代表定义函数的个数，1代表window

#### 作用域和执行上下文

区别1：

- 作用域在函数定义时就确定的，不是函数调用时
- 全局执行上下文是全局作用域确定后创建的
- 函数执行上下文是调用函数时，函数执行前创建的

区别2：

- 作用域是静态的，只要函数定义好了就一直存在，且不会变化
- 执行上下文是动态的，调用函数时创建，函数调用结束时，自动释放

联系：

- 执行上下文从属于所在的作用域链
- 全局执行上下文==》全局作用域
- 函数执行上下文==》对应函数作用域

### 闭包

闭包产生的条件：

- 函数嵌套。
- 内部函数引用了外部函数的数据（变量/函数）

通过chrome调试工具可以查看闭包

- 闭包是一种函数，闭包是一种现象。

#### 常见的闭包

1. 将一个函数作为另一个函数的返回值
2. 将函数作为实参传递给另一个函数
