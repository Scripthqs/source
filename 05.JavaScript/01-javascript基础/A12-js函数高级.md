# 函数高级

## 1、原型与原型链

### 1.1、原型(prototype)

- 每个函数对象都有一个prototype属性，该属性默认对应一个`{}`(空对象)，称为原型对象。这个空对象`{}`是Object的实例对象。
- 原型对象都有一个constructor属性，指向函数对象。

空对象表示没有我们自己添加的属性。

给原型对象添加属性（方法）===》实例对象可以访问。

### 1.2、显式原型和隐式原型

- 每个函数对象都有一个prototype属性，称为显式原型属性，默认指向`{}`空实例对象。
- 每个实例对象都有一个__proto__属性，称为隐式原型属性。
- 构造函数对象的显示原型===实例对象的隐式原型
  - Function是new Function()产生的
  - Object也是new Function()产生的
- 所有函数的__proto__都是一样的

- 函数的prototype属性：在定义函数时自动添加的，默认值是Object空对象。
- 对象的__proto__属性：创建对象时自动添加的，默认值为构造函数的prototype属性值。
- 不要直接操作隐式原型(ES6之前)。

### 1.3、原型链

- 访问一个对象的属性，先在自身寻找，找到返回
- 找不到沿着__proto__这条链找，找到返回
- 最终没找到，返回undefined
- 原型链别名隐式原型链

作用：查找对象属性（方法）

### 1.4、原型的继承

- 构造函数的实例对象自动拥有构造函数原型对象的属性（方法）
-  原理：原型链

1. 所有函数的显示原型指向的对象是空Object实例对象(Object不满足)
   - `Object.prototype instanceof Object`//false
2. 所有函数都是Function的实例，包括Function本身和Object
   - `Function.__proto===Function.prototype`
3. Object的原型对象是原型链的尽头
   - `object.prototype.__proto__`//null

### 1.5、instanceof

- A instanceof B
- 如果B函数的显式原型对象在A对象的原型链上，返回true，否则返回false。

## 2、回调函数

什么是回调函数？

- 你定义的
- 你没有调用
- 但最终函数执行了

常见的回调函数？

- DOM事件的回调函数
- 定时器回调函数
- Ajax请求回调函数
- 生命周期回调函数

## 3、IIFE

IIFE；Immediately-Invoked Function Expression（立即调用的函数表达式），也称为`匿名函数自调用`

使用IIFE的好处：

- 不必为函数命名，避免了污染全局变量
- IIFE 内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量。

## 4、this

- `fun()`this是window
- `obj.fun()`this是obj
- `var p = new test()`this是新建的对象p
- `p.call(obj)`this是obj

## 5、闭包

闭包产生的条件：

- 函数嵌套。
- 内部函数引用了外部函数的数据（变量/函数）

通过chrome调试工具可以查看闭包

- 闭包是一种函数，闭包是一种现象。

### 5.1、常见的闭包

1. 将一个函数作为另一个函数的返回值
2. 将函数作为实参传递给另一个函数

### 5.2、闭包的作用

- 函数执行完后，延长变量的生命周期
- 让函数外部可以操作内部的数据变量

- 在函数执行完后，函数内部的局部变量一般不会存在，除了闭包中的变量。
- 函数外部不能访问函数内部的局部变量，但可以通过闭包让外部来操作内部的局部变量。

### 5.3、闭包的产生和死亡

- 在嵌套内部函数时就产生了（不是调用）
- 在嵌套的内部函数成为垃圾对象时死亡 f=null

### 5.4、闭包的应用

定义JS模块

- 具有特定功能的JS文件
- 将所有数据和功能都封装到一个函数内部（私有的）
- 只向外暴露一个包含n个方法的对象和函数
- 模块的使用者，只需要通过模块暴露的对象调用方法来实现对应的功能

如何向外暴露方法：通过return 或者在函数内部添加window的方法

### 5.5、闭包的的缺点

- 函数执行完后，函数内的局部变量没有释放，占用内存时间会变长。
- 要即使释放`f = null`

### 5.6、内存溢出和内存泄漏

内存溢出：

- 当程序运行所需的内存超过了剩余的内存，就会抛出内存溢出错误

内存泄漏：

- 内存泄露指用不到（访问不到）的变量，依然占据这内存空间，不能被再次利用。
- 占用的内存没有及时释放
- 内存泄漏过多就会导致内存溢出

常见的内存泄漏：

- 意外的全局变量
- 没有及时清理的计时器或回调函数
- 闭包不会导致内存泄漏也有说会
