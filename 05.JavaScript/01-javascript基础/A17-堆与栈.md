# 变量、内存、数据

## 1、变量

变量：程序向内存申请的一块可以存储数据的空间

- JS中，所有的变量都保存在**栈内存**中的。
- 变量需要的声明和赋值
- 变量名：查找对应的内存
- 变量值：内存中保存的数据

## 2、内存

内存：内存条通电后产生的可存储数据的临时空间

- 内存分为栈内存和堆内存
- 基本数据类型的值，直接保存在**栈内存**中。
- 对象数据类型的值保存在**堆内存**中的，而对象的引用（即变量）是保存在**栈内存中**的。

内存的产生和死亡：

- 内存条是电子元器件组成的电路板
- 内存的产生：内存条->通电->产生内存空间—>存储数据->处理数据
- 内存的死亡：断电->内存空间消失，数据同时消失

内存是**临时存储**空间，硬盘是永久存储空间。内存速度快，硬盘慢。

## 3、数据

数据：存储在内存中的信息，本质是010101····

- 在计算机中，不同的数据所需的存储空间不同，为了充分利用存储空间，就定义了不同的数据类型
- JS将数据分为**基本数据类型和引用（对象）数据类型**两大类
- 数据可传递、可运算

## 4、栈内存和堆内存

**JS中，所有的变量都保存在栈内存中的**。

### 4.1、基本数据类型

基本数据类型的值，直接保存在**栈内存**中。值和值相互独立，修改一个变量不会影响其他变量。

### 4.2、引用数据类型

对象是保存在**堆内存**中的，每创建一个新的对象，就会在堆内存中开辟一个新的空间；而变量保存了对象的内存地址（对象的引用），保存在栈内存中。如果两个变量保存了同一对象的引用，当一个通过一个变量修改属性时，另一个也会受到影响。

- **对象的值是保存在堆内存中的，而对象的引用（即变量）是保存在栈内存中的**。

## 5、联系

### 5.1、对象是变量吗？

当然不是，对象是数据类型，变量是内存的标识，通过变量才可以使用内存，不可以直接说对象是变量。

### 5.2、obj.name

`obj.name`其中的`.`的含义是沿着地址找到内容，只有地址数据才能`.`

### 5.3、var a = xxx

- xxx是基本数据类型，保存的就是这个数据
- xxx是引用数据类型，保存的就是对象的地址值
- xxx是变量，保存的是xxx的内存内容，可能是基本数据，也可能是地址值。

## 6、浅拷贝和深拷贝

- 浅拷贝：只拷贝最外面一层的数据，更深层次的对象，只拷贝引用
- 深拷贝：拷贝多层数据，每一层级别的数据都会拷贝
- 拷贝引用时，属于传址，而非传值
- 深拷贝会把对象里所有的的数据重新复制到新的内存空间，是最彻底的拷贝

### 6.1、浅拷贝的实现方式

- 用for in 实现浅拷贝

````js
        var obj1 = {
            a : 1,
            b :'2',
            f:{
                name:'haha'
            }
        };
        var obj2 = {};
        for(var key in obj1){
            obj2[key] = obj1[key];
        }
        console.log(obj1);
        console.log(obj2);
        obj1.a = 999;
        obj1.f.name='hehe';//修改obj1的属性
        console.log(obj1);
        console.log(obj2);
````

在 obj2 中， a 和 b 这两个属性会单独存放在新的内存地址中，和 obj1 没有关系，但是 obj2.f 属性还是和 obj1.f 指向同一个堆内存地址

- 用 Object.assgin() 实现浅拷贝（ES6新语法，推荐的方式）
- 语法1`obj2 = Object.assgin(obj2, obj1);`
- 语法2`Object.assign(目标对象, 源对象1, 源对象2...);`
- `const obj2 = Object.assign({}, obj1);`
- `Object.assign(obj2,obj1);`相当于常量中的`obj2=obj1`
- 将obj1 拷贝给 obj2。执行完毕后，obj2 的值会被更新，如果对象里的属性名相同，会被覆盖
- Object.assign() 可以将多个“源对象”拷贝到“目标对象”中

````js
    const myObj = {
        name: '法外狂徒张三',
        age: 17,
    };

    // 【写法1】浅拷贝：把 myObj 拷贝给 obj1
    const obj1 = {};
    Object.assign(obj1, myObj);

    // 【写法2】浅拷贝：把 myObj 拷贝给 obj2
    const obj2 = Object.assign({}, myObj);

    // 【写法3】浅拷贝：把 myObj 拷贝给 obj31。注意，这里的 obj31 和 obj32 其实是等价的，他们指向了同一个内存地址
    const obj31 = {};
    const obj32 = Object.assign(obj31, myObj);
````

### 6.2、深拷贝的实现方式

深拷贝其实就是将浅拷贝进行递归。

- 用 for in 递归实现深拷贝

````js
        var obj1 = {
            a: 1,
            b: '2',
            f: {
                name: 'haha'
            },
            color: ['red', 'blue', 'green']
        };
        var obj2 = {};
        deepCopy(obj2, obj1);
        console.log(obj2);
        obj1.f.name = 'hehe';
        console.log(obj1);
        console.log(obj2);
        function deepCopy(newObj, oldObj) {
            for (let key in oldObj) {
                //let item = oldObj[key];
                if (oldObj[key] instanceof Array) {
                    newObj[key] = [];
                    deepCopy(newObj[key], oldObj[key]);
                } else if (oldObj[key] instanceof Object) {
                    newObj[key] = {};
                    deepCopy(newObj[key], oldObj[key]);
                } else {
                    newObj[key] = oldObj[key];
                }
            }
        }
````

