# JavaScript基础知识

## JavaScript的书写位置

HTML中推荐双引号，js中推荐单引号。js严格区分大小写。以分号结尾但是可以省略。
有3种方式引入js代码：

- 行内式：直接写HTML标签的事件中
- 内嵌式：直接编写到`<script>`标签中。
- 引入外部JS文件`<script src="tool.js"></script>`

## JavaScript输入输出语句

- 弹出警告框 `alert()`
- 控制台输出 `console.log()`
- 向body中输入内容 `document.write()`
- 弹出输入框 `prompt()`，用户不管输入什么内容，都是字符串。我们可以用一个变量，来接收用户输入的内容。

## 字面量和变量

### 字面量

字面量即常量，不可改变的量。

- 数字 12345
- 字符串 单词句子'123' 'word' '吃饭'
- 布尔值 true false

字面量都可以直接使用，但是我们都不会直接使用字面量。一般定义一个变量来保存这个字面量。

### 变量

变量是程序向内存申请的一块可以存储数据的空间。变量需要的声明和赋值。

- 声明/定义变量
  - `var name;`声明一个名为`name`的变量。ES6之前都用`var`
  - `const name;` 定义一个常量
  - `let age;` 定义一个变量

- 变量的赋值
  - `name = 'haha'` 变量名=变量值

变量的声明和赋值可以写在一起。

- var a = 100;
- const b = 'hello'
- let b = 'world'

声明一个变量并赋值，称为变量的初始化。

声明变量要点：

- 变量新赋值，以最后一次赋值为准
- 同时声明多个变量，多个变量名用`,`隔开。var name = 'a' , age =18;
- 变量建议先声明再使用。
- 变量名严格区分大小写。
- 定义但为赋值的变量结果显示`undefined`

## 区块

JavaScript使用大括号，将多个语句组合起来，称为区块。对于`var`命令，JavaScript的区块不构成单独的作用域（scope）。

````js
{
    var a = 1;
}
a
````

在区块内部，使用var声明并赋值的变量a，在区块外部依然有效。区块对于var不构成单独的作用域。

## 标识符、关键字、保留字

### 标识符

标识符：在js中可以由我们自主命名的都可以称为标识符。

变量名、函数名、属性名、参数名都是标识符。我们写代码时取的名字就是标识符。

- 可以含有字母、数字、`_`、`$`
- 不能以数字开头
- 不能是关键字和保留字
- 一般使用驼峰命名法，首字母小写，每个单词开头大写，`helloWorld` `tuoFengMingFa`
- 或者下划线方法`hello_world`

### 关键字

JS本身已经使用得单词，不能再用来充当变量。

### 保留字

预备关键字

### 变量的数据类型

在计算机中，不同的数据所需的存储空间不同，为了充分利用存储空间，就定义了不同的数据类型。js中一共有6种数据类型，5种基本数据类型（值类型），1种引用数据类型（引用类型）。

- `String` 字符串
- `Number` 数值
- `Boolean` 布尔值
- `Null` 空值
- `Undefined` 未定义
- `Object` 对象

变量的数据类型是可以变化的，`var name = 'a'; name = 1;` 此时，变量name由字符串变成了数字类型。

基本数据类型和引用数据类型的最大区别：

- 基本数据类型：参数赋值时，传数值。
- 引用数据类型：参数赋值时，传地址。

引用数据类型只有1种，但是可以分为3个子类型

- 狭义的对象 object
- 数组 array
- 函数 function

## 栈内存和堆内存

JS中，所有的变量都保存在**栈内存**中的。

### 基本数据类型

基本数据类型的值，直接保存在**栈内存**中。值和值相互独立，修改一个变量不会影响其他变量。

### 引用数据类型

对象是保存在**堆内存**中的，每创建一个新的对象，就会在堆内存中开辟一个新的空间；而变量保存了对象的内存地址（对象的引用），保存在栈内存中。如果两个变量保存了同一对象的引用，当一个通过一个变量修改属性时，另一个也会受到影响。

- 对象的值是保存在堆内存中的，而对象的引用（即变量）是保存在栈内存中的。

## typeof 运算符

JavaScript有3种方法确定值到底是什么类型。

- typeof 运算符
- instanceof 运算符
- Object.prototype.toString 方法

`typepf`运算符可以返回一个值的数据类型。它会将该值的类型以字符串的形式返回。

````js
// 写法1
typeof 变量;

// 写法2
typeof(变量);
````

- 数值返回 `'number'`
- 字符串返回 `'string'`
- 布尔值返回 `'boolean'`
- 函数返回 `'function'`
- undefined返回 `'undefined'`
- null返回 `'object'` 特殊，因为在1995年时，没有考虑null，把null当作object的特殊值。

`typeof`可以用来检查一个没有声明的变量，而不报错。

````js
v
// ReferenceError: v is not defined
typeof v
// "undefined"
````

变量v没有用var命令声明，直接使用就会报错。但是，放在typeof后面，就不报错了，而是返回undefined。

### String字符串

字符串使用单引号或者双引号。要点：

- `''`引号间什么都不写，称为空字符串。
- 同类引号不能嵌套。
- 对于一些特殊的符号，可以使用`\`作为转义字符。
  - `\'` 单引号
  - `\"` 双引号
  - `\n` 换行
  - `\r`回车
  - `\b`空格
  
### 获取字符串的长度

字符串由若干份字符串组成，这些字符的数量就是字符串的长度，可以通过length属性获取整个字符串的长度。

````js
        var str1 = '你好';
        var str2 = 'hello';
        var str3 = 'hello world';
        var str4 = 'hello,world';
        console.log(str1.length); // 2
        console.log(str2.length); // 5
        console.log(str3.length); // 11
        console.log(str4.length); // 11
````

- 一个中文、英文都算一个字符
- 一个中文标点、英文标点算一个字符
- 一个空格算一个字符，多个连续空格也算多个字符。

### 字符串的拼接

多个字符串之间可以使用加号 `+` 进行拼接。

`字符串 + 任意数据类型 = 拼接之后的新字符串`

拼接前，任意数据类型会强制转换成字符串，然后再拼接成一个新的字符串。应用：

- `'' + 任意数据类型` 可以强制转换成字符串

### 字符串与数组

- 字符串可以视为字符数组，因此可以使用方括号运算符，用来返回某个位置的字符，从0开始。

````js
        var s = 'hello';
        console.log(s[0])// "h"
        console.log(s[1])// "e"
        console.log(s[4])// "o"
        // 直接对字符串使用方括号运算符
        console.log('hello'[1]) // "e"
````

- 如果方括号中的数字超过字符串的长度，或者方括号中根本不是数字，则返回undefined。
- 字符串与数组的相似性仅此而已。实际上，无法改变字符串之中的单个字符。

### 字符串的不可改变性

字符串里面的值不可被改变，虽然看上去内容变了，其实是地址变了，内存中开辟了新的空间。

````js
var str = 'hello';
str = 'world';
````

当重新给变量str赋值时，常量'hello'不会被修改，依然保存在内存中，str会改为指向`world`。

### 模板字符串（模板字面量）

````js
          var name = 'tom';
          var age = '17';
          console.log('我是' + name + ',age:' + age);//传统写法
          console.log(`我是${name},age:${age}`);//ES6新语法
````

注意：ES6新语法括号中不是单引号，而是TAB键上方的符号。

- 模板字符串中可以直接换行

````js
          var name = 'tom';
          var age = '17';
          console.log(`我是${name},
          age:${age}`);//ES6新语法
````

- 在模板字符串中插入表达式

````js
          var a = 2;
          var b = 1;
          console.log(`和为${a+b}，积为${a*b}`);//ES6新语法
````

- 模板字符串中可以调用函数
- 模板字符串支持嵌套使用

## Number数值

JS中所有的数值都是Number类型，包括整数和浮点数（小数）。JavaScript 语言的底层根本没有整数，所有数字都是小数（64位浮点数），1与1.0是相同的，是同一个数。JavaScript 内部实际上存在2个0：一个是+0，一个是-0，区别就是64位浮点数表示法的符号位不同。它们是等价的。但是，当+0或-0当作分母，返回的值是不相等的。因为除以正零得到+Infinity，除以负零得到-Infinity，这两者是不相等的。

- 精度最多只能到53个二进制位，绝对值小于2的53次方的整数，即-2^53到2^53,都可以精确表示。
- 能够表示的数值范围为2^1024到2^-1023（开区间），超出这个范围的数无法表示。
- JavaScript 提供Number对象的MAX_VALUE和MIN_VALUE属性，返回可以表示的具体的最大值和最小值。

当Number表示的变量超过了最大值，则会返回infinity。

- 正无穷 infinity
  - Infinity与null计算时，null会转成0，等同于与0的计算。
  - Infinity与undefined计算，返回的都是NaN。
- 负无穷 -infinity
- 特殊的数字 NaN not a number，非数值。NaN在布尔运算时被当作false。
- 这三个值使用typeof的结果都是Number。

NaN与任何值都不相等，包括NaN本身，Undefined和任何数值计算的结果都是NaN。

`+`只有在两边都是Number类型时，才是数字相加，否则就是连字符，用来连接字符串。

`-`时，"2"-1得到的结果却是数值1，字符串会自动做隐式转换。

### 数字进制

- 十进制：没有前导0的数值。
- 八进制：有前缀0o或0O的数值，或者有前导0、且只用到0-7的八个阿拉伯数字的数值。
- 十六进制：有前缀0x或0X的数值。
- 二进制：有前缀0b或0B的数值

### 运算精度

JS中整数运算基本可以保证准确，小数运算很可能得到一个不准确的结果。要进行准确的运算的方法；

- 简单精度 使用`toFix()`方法进行小数的截取
- 实际开发中，可以使用数学运算开源库
  - Math.js 文件很大，压缩的文件500kb，涉及大型的复杂运算使用
  - decimal.js 轻量的运算库，压缩的文件32kb，大多数数学运算项目都可以满足。

开源库既可以使用cdn的方式引用，也可以使用npm包的方式引入。

### 关于数值相关的全局方法

1. parseInt()将字符串转换成整数
   - 头部空格会自动消除- 不是字符串，则会先转为字符串再转换
   - 第一个字符不能转换成数字（除后面直接跟着数字的正负号），返回NaN。
   - 返回值只有两种可能，十进制整数或者NaN。
   - 字符串以0x或0X开头，parseInt会将其按照十六进制数解析
   - 如果字符串以0开头，将其按照10进制解析或者8进制。
   - 科学计数法不好使，e会被当成普通字母。
   - parseInt方法还可以接受第二个参数（2到36之间，如果第二个参数没有意义则会被忽略），表示被解析的值的进制。默认值是10。

      ````js
                parseInt(1000000000000000000000.5) // 1
                // 等同于
                parseInt('1e+21') // 1
                parseInt(0.0000008) // 8
                // 等同于
                parseInt('8e-7') // 8
      ````

      ````js
                parseInt('1000', 2) // 8
                parseInt('1000', 6) // 216
                parseInt('1000', 8) // 512
      ````

2. parseFloat()将一个字符串转为浮点数。
   - 科学计数法好使。
   - 空字符串转为NaN。

3. isNaN()方法可以用来判断一个值是否为NaN。
   - 只对数值有效，如果传入其他值，会被先转成数值。
   - isNaN为true的值，有可能不是NaN，而是一个字符串。
   - 对于对象和数组，isNaN也返回true。
   - 但是对于空数组和只有一个数值成员的数组，isNaN又返回false。
   - NaN是唯一不等于自身的值，这是最可靠的方法。
  
````js
          function myIsNaN(value) {
            return value !== value;
          }
````

1. isFinite()方法返回一个布尔值，表示某个值是否为正常的数值。
   - Infinity、-Infinity、NaN和undefined这几个值会返回false
   - `isFinite`对于其他的数值都会返回true。

## Boolean布尔值

布尔值有两个`true` 和 `false`。千万不能加引号，主要用来做逻辑判断：

- true 表示真
- false 表示假

布尔型和数字型相加时，

- true 按 1 来算
- false 按 0 来算

对于以下几个值转换成布尔值时为false，其他都是true。

- undefined
- null
- false
- 0
- NaN
- ""或'' 空字符串

注意：空数组（[]）和空对象（{}）对应的布尔值，都是true。

## Null和Undefined

null专门用来定义空对象，如果想定义一个变量引用类型，但是暂时还没想好放什么内容，可以设置为null。

- Null类型的值只有一个，就是null。
- 使用typeof检查一个null值时，会返回object。

undefined未定义，使用的情况：

- 变量已声明，但未赋值，此时该变量的值就是undefined
- 变量未声明未定义时，直接使用会报错，使用typeof检查则返回undefined。
- 如果一个函数没有返回值，那么，这个函数的返回值就是 undefined。在定义一个函数时，如果末尾没有return语句，那么其实就是`return undefined`
- 调用函数时，如果没有传参，那么这个值就是undefined。

### null和undefined的区别

- null == undefined 为true
- null === undefined 为false
- 和数字做运算时：
  - 10 + null 结果时10
  - 10 + undefined 结果为NaN

任何数据类型和undefined运算都是NaN，任何值和null运算都相当于和0运算。

### 强制的类型转换

将一个数据类型强制转换成其它的数据类型。类型转换主要指将其他的数据类型转换为String Number Boolean。

### 将其他数据类型转换成String

- 调用被转换数据类型的toString()方法。
  - 该方法不会影响原变量，它会将转换的结果返回
  - 调用xxx的yyy方法，就是xxx.yyy
  - `var a = a.toString();`
  - 注意：null和undefined两者值没有toString()方法。
- 调用String()函数，并将转换的数据作为参数传递给函数。
  - 调用xxx函数，就是xxx();
  - `var a = String(a);`
  - 使用String()函数做强制转换时，对于Number和Boolean实际上就是调用的toString()方法，对于Null和Undefined则是直接转换成"Null"和"Undefined"

### 将其他数据类型转换成Number

- 调用Number()函数，并将转换的数据作为参数传递给函数。
  - `var b = Number(b);`
  - 纯数字字符串转换成数字
  - 含有非数字内容转换成NaN
  - 空串和全空格转换成0
  - 布尔值true转换成1，false转换成0
  - null转换成0，undefined转换成NaN
- parseInt()将一个字符串转换成整数，专门处理字符串
  - 可以将一个字符串的有效整数取出来
  - `var c = parseInt(c);`
- parseFloat()将一个字符串转换成小数
  - 可以将一个字符串的有效小数取出来，专门处理字符串
  - `var c = parseInt(c);`
- parseInt()和parseFloat()会将非字符串会先转换字符串再操作。

### 将其他数据类型转换成Boolean

- 使用Boolean()函数，并将转换的数据类型作为参数传递给函数。
  - `var d = Boolean(d);`
  - Number类型中，除了0和NaN，其余的都是true
  - String中，除了空串`''`，其余的都是true
  - null和undefined都会转换成false
  - 对象也会转换成true

## 隐私类型转换

- 任意数据类型和String`+`时，结果会变成字符串拼接。
  - `var a = a + ''`
  - 加上一个空字符串`''`，即可将a转换成字符串，这个方法等价于`var a = String(a);`
- 任意数据类型和Number`-` 、`*`、`/`都会转换成Number。
  - `var b = b - 0`、`var b = b * 1`、`var b = b / 1`
  - 更简单的写法 `var b = +b`
- 任意数据类型做两次非运算即可转换成Boolean
  - `var c = !!c`

## 自增自减

- `a++`和`++a`
  - 无论是哪一种都会使原变量自增1
  - 不同的是`a++`和`a++`的值不同，`a++`的是原值，`++a`是新值

````js
var a = 1;
a = a++;//a=1
a = ++a;//a=2
````

- `a--`和`--a`
  - 无论是哪一种都会使原变量自减1
  - 不同的是`a--`和`--a`的值不同，`a--`的是原则，`--a`是新值

## 逻辑运算符

- `!`非 取反
- `&&`与 全1出1，有0出0
  - `a&&alert('我出不出来')`
  - 如果第一个值为`false`则不再看第二个值，此时alert()语句将不会输出
  - `a&&b`
  - 如果两个值都是`true`，则返回后面一个

- `||`或 有1出1，全0出0
  - `b||alert('我出不出来')`
  - 如果第一个值为`true`则不再看第二个值，此时alert()语句将不会输出
  - 如果两个值都是`false`，则返回后面一个

## 关系运算符

- `>`或者`<`，关系成立则返回`true`，不成立则返回`false`
- 对于非数值的关系运算，会将其转换成数字
- `NaN`和任何值比较都是NaN
- 如果符号两侧的值都是字符串，不会将其转换成数字进行比较，而是分别比较字符串的字符的Unicode编码
- 比较字符编码的是一位一位的比较，如果两位一样则比较下一位
  - 这种方法可以用作字母排序
- 比较两个字符串型的数字时，一定要转型
- `\uxxxx`转义字符`\u`表示Unicode编码
- '=='相等运算符会做类型转换
  - `null==0`是false
  - `null==undefined`是true
  - NaN不和任何值相等，包括它本身

## 条件运算符

条件运算符，又称三元运算符，`条件表达式?语句1:语句2;`

- 条件表达式为true，执行语句1
- 条件表达式为false，执行语句2
- `a>b?a:b`获取a、b中的较大值
- 如果条件表达式不是布尔值，则会先准换成布尔值

## 运算符优先级

- `,`运算符可以分割多个语句，同时声明多个变量
  - `var a,b,c;` `var a=1,b=2,c=3;`
- 与`&&`的优先级比`||`高
  - `1||2&&3`结果为1
- 遇到优先级拿不准的直接加括号`()`

## 语句和代码块

语句(statement)，在J中可以使用`{}`将语句分组，同一个`{}`中的语句称为代码块，里面的内容要么都执行，要么都不执行，结尾不用编写分号。

- JS中的代码块只有分组的作用，代码块中的内容，在外部是完全可见的。

## 流程控制语句

语句有3种结构：

- 顺序结构
- 选择结构 if语句、switch语句
- 循环结构 while语句、for语句

语句有三种：

- 条件判断语句 条件成立才执行
- 条件分支语句
- 循环语句

## if语句

- 语法1：

````js
        if(条件表达式){
          语句;//条件表达式为true，执行
        }
````

- 语法2：

````js
        if(条件表达式){
          语句1;
        }else{
          语句2;
        }
````

````js
        if(条件表达式1){
          语句1；
        }else if(条件表达式2){
          语句2；
        }else{
          语句3；
        }
````

从上到下依次判断，一旦出现条件表达式为`true`的情况，直接结束if语句，不管后面的条件表达式。

## switch语句

语法：

````js
        switch(条件表达式){
          case 值1:
            语句1;
            break;
          case 值2:
            语句2;
            break;
            ···
            ···
          default:
            语句n;
            break;
        }
````

计算出表达式的值，和case依次全等比较，比较结果为true，则从当前case处执行代码。

````js
        var m = +prompt('请输入分数');
        switch(true){
            case m >= 60: 
                console.log('合格')
                break;
            default:
                console.log('不合格');
                break;
        }
````

js独有的方式，case后面可以跟表达式。

## while语句

语法：

````js
        while(条件表达式){
          语句···
        }
````

执行流程：
先对条件表达式进行求值判断：

- 值为true，则执行循环体
- 循环体执行完毕后，继续对表达式进行判断
  - 如果为true，则继续执行循环体
  - 直到值false，如果没有则陷入`死循环`
- 如果有必要，可以使用break来终止循环

创建一个循环往往需要3个步骤：

- 初始化一个变量
- 在循环中设置一个条件表达式
- 定义一个更新表达式，每次更新初始化变量

````js
         var n=1;//初始化一个变量
        while(n<10){//条件表达式
            console.log(n);
            n++;//更新表达式
        }
````

do...while语句和while语句的区别；

- do...while语句先执行后判断
- while语句先判断后执行

## for语句

语法

````js
        for(初始化表达式;条件表达式;更新表达式){
          语句···
        }
````

执行流程：

- 执行初始化表达式，初始化变量，初始化表达式只会执行一次
- 执行条件表达式，判断是否执行循环
  - 值为true，则执行循环
  - 值为false，终止循环，此时语句将不再执行
- 执行更新表达式，更新表达式执行完毕后，继续执行条件表达式，判断是否继续循环

for循环的三个表达式都可以省略，也可以写在外部。

- 如果不写任何表达式，只写两个`;;`，代表死循环

````js
        for(;;){
          语句···//死循环
        }
````

利用parseInt()方法或者Math.floor()取三位数的各位：

- 百位：`parseInt(i/100)`
- 十位：`parseInt(i%100/10)`或者 `parseInt((i-百位*100)/10)`
- 个位：`i%10`

关于取多位数各位数的规律，多位数除以`/`和取余的效果`%`:

- `/10`  会去除个位
- `/100` 会去除十位及以下
- 依次类推
- `%10` 会留下个位
- `%100` 会留下十位及以下，如果只留下了一位数，代表这个多位数十位必然是0

总结：`/`是去除，`%`是留下。

### for嵌套

````js
        for( var i = 1; i <= 5; i++){
            for(var j = 1; j <= 5; j++){
                document.write("* &nbsp;")
            }
            document.write("<br/>")
        }
````

- 5行5列的*
- 外层的参数`i`会影响高度，列数
- 内层的参数`j`会影响宽度，行数

打印1-100间的质数

````js
        for (i = 2; i <= 100; i++) {
            var f = true;
            for (j = 2; j < i; j++) {
                if (i % j == 0) {
                    f = false;
                }
            }
            if (f) {
                console.log(i);
            }
        }
````

## break 和 continue

- `if语句`不能使用`break`和`continue`，否则会报错。
- `break`关键字可以退出switch语句或者循环语句(循环语句包括for循环、while循环、不包括if)
- `break`会立即终止离他最近的那个循环语句
- 可以为循环语句创建一个label，`lable:循环语句`，来标识当前循环，可以在 break 后跟着一个 label，这样 break 将会结束指定的循环，而不是最近的。

````js
        for (var i = 0; i < 5; i++) {
            if (i == 2) {
                break; // 注意，虽然在 if 里 使用了 break，但这里的 break 是服务于外面的 for 循环。
            }
            console.log('i的值:' + i);
        }
````

````js
        outer: for (var i = 0; i < 5; i++) {//创建一个label
            console.log('外层循环 i 的值：' + i);
            for (var j = 0; j < 5; j++) {
                break outer; // 直接跳出outer所在的外层循环（这个outer是我自定义的label）
                console.log('内层循环 j 的值:' + j);
            }
        }
````

- `continue`可以用来跳过当次循环，继续下次循环
- `continue`默认只会对离他最近的循环起作用
- 如果需要跳过指定的当次循环，可以使用lable标签

````js
        for (var i = 0; i < 5; i++) {
            if (i == 2) {
                continue; 
            }
            console.log('i的值:' + i);
        }
````

## 测试代码的执行时间

- `console.time('计时器名字')`可以用来开启一个计时器，需要一个字符串作为参数，这个字符串会作为计时器的标识。
- `console.timeEnd('计时器名字')`可以用来停止一个计时器，需要一个字符串作为参数，这个字符串会作为计时器的标识。
- `Math.sqrt()`可以对一个数进行开方。

## 对象

- 只要不是那五种基本数据类型，就全都是对象。
- 对象是一组无序的相关属性和方法的集合。
- 对象的作用的封装信息。比如Student类里可以封装学生的姓名、年龄和成绩。
- 对象具有特征（属性）和行为（方法）。
- 简单说，对象就是一组“键值对”（key-value）的集合，是一种无序的复合数据集合。

### 面向对象

- 面向对象：可以创建自定义的类型，很好的支持继承和多态。
- 面向对象的特征：封装、继承、多态。
- 面向对象两个步骤：找对象、搞对象

### 对象的分类

- 内建对象
  - 由ES标准中定义的对象，在任何的ES实现中都可以使用。
  - 比如：Object、Math、Date、String、Array、Number、Boolean、Function等。
- 宿主对象
  - 由JS运行环境提供的对象，目前来讲主要是浏览器提供的对象。
  - 比如BOM DOM，比如：`console`、`document`
- 自定义对象
  - 由开发人员自己创建的对象
  - 通过new关键字创建出来的对象实例，都是属于对象的类型。

### 创建对象

使用构造函数来创建对象：

- `var obj = new Object();`
- 使用new关键字调用的函数，是构造函数constructor。
- 构造函数是专门用来创建对象的函数。

使用对象字面量来创建对象：

- `var obj = {};`

添加属性

- `对象.属性名 = 属性值;`

删除属性

- `delete 对象.属性名;`

如果使用特殊的属性名，不能采用`.`的形式来操作，而需要

- `对象['属性名'] = 属性值`
- 读取也需要同样的方式
- 使用这种方式操作属性更加灵活，`[]`间可以直接传递一个变量

### in运算符

in运算符可以检查一个对象中是否含有指定的属性。

- `'属性名' in 对象`
- 有则返回true
- 无则返回false

### 基本数据类型和引用数据类型的重点

````js
var obj = new Object();//对象的引用
obj.name = 'haha';
````

- JS中，所有的变量都保存在**栈内存**中的。
- 基本数据类型的值，直接保存在**栈内存**中。值和值相互独立，修改一个变量不会影响其他变量。
- 对象是保存到**堆内存**中的，每创建一个新的对象，就会在堆内存中开辟出一个新的空间（这个空间会有一个内存地址）。变量保存的是对象的内存地址（对象的引用）。
- 对象的**值是保存在堆内存**中的，而对象的**引用（即变量）是保存在栈内存**中的。
- 如果两个变量保存的是同一个对象引用，当一个通过一个变量修改属性时，另一个也会受到影响。
- 对象比较是比内存地址。

### 对象字面量

以构造函数的形式创建对象

- `var obj = new Object();`
- obj.name = 'aaa';

使用对象字面量来创建对象：

- `var obj = {};`

使用对象字面量创建对象时，可以直接指定对象中的属性：

````js
var obj = {
  name:'a',
  age:25,
  gender:'男'
}
````

### 键值对、属性、方法

````js
        var obj = {
          foo: 'Hello',
          bar: 'World'
          test: {
            name:'a',
            age:12
          }
        };
````

代码分析：

- 1个`{}`就定义了一个对象，赋值给变量`obj`，所以`obj`就指向一个对象.
- 内部包括两个键值对（或者说两个成员），`键名:'键值'`，多个键值对用`,`隔开。
  - CSS的属性语法：`属性：属性值;` 多个属性之间用`;`隔开，多个属性值用`,`隔开。`width:800px;`
  - HTML的属性语法：`属性="属性值"` 多个属性之间用**空格**隔开。`<font color="red" size="3">文字</font>`  
- 键名都是字符串，但是可以不加`''`，如果键名是数值，自动转为字符串。
- 不过，对于不符合标识符的键名，必须要加`''`。
- 对象的每一个键名又称**属性（property）**，它的键值可以是任何数据类型。
- 当键值是函数时，通常把这个属性称为**方法**。
- 当键值时对象时，就会形成链式引用。
- 属性可以动态创建，不必在对象声明时就指定。

### 对象和代码块

`{ foo: 123 }`可能会有两种含义，对象或者代码块。

- 如果遇到这种情况，无法确定是对象还是代码块，一律解释为代码块。
- 如果要解释为对象，最好在大括号前加上圆括号。

````js
({ foo: 123 }) // 正确
({ console.log(123) }) // 报错
````

## 函数

- 函数也是对象
- 函数中可以封装一些功能（代码），在需要时可以只写这些功能和代码
- 可以将要封装的的代码以**字符串的形式**传递给构造函数
- 封装的代码不会立即执行
- 函数代码会在函数调用的时候执行，
- 所有的函数，都是 Fuction 的“实例”（或者说是“实例对象”）。函数本质上都是通过 new Function 得到的。
- 函数既然是实例对象，那么，函数也属于“对象”。

### 创建函数对象

1. 以构造函数的方式创建函数：

   - `var fun = new Function();`
   - 实际开发中，不会使用这种方式

2. 使用函数声明来创建函数：

    ````js
            function 函数名([形参1,形参2...形参N]){  
              语句...
            }
    ````

    ````js
            function fun1(a, b){
              return a+b;
            }
    ````

   - 备注：语法中的中括号，表示“可选”

3. 函数表达式（匿名函数）

    ````js
            var 变量名  = function([形参1,形参2...形参N]){
              语句....
            }
    ````

    ````js
            var fun2 = function() {
              console.log("我是匿名函数中封装的代码");
            };
    ````

### 函数的调用

- 普通函数的调用，语法：`函数();`或者`函数名.call();`。
- 通过对象的方法来调用，如果一个函数是作为一个对象的属性保存，那么，我们称这个函数是这个对象的方法。`obj.fn2(); // 调用函数`
- 立即执行函数

````js
        (function (){
            console.log('匿名函数')
        })();
````

- 通过构造函数来调用
- 绑定事件函数
- 定时器函数

````js
    let num = 1;
   setInterval(function () {
       num ++;
       console.log(num);
   }, 1000);
````

### 形参和实参

形参：

- 形式上的参数。定义函数时传递的参数，当时并不知道是什么值。
- 定义函数时，可以在函数的()中来指定一个或多个形参。
- 多个形参之间使用,隔开，声明形参就相当于在函数内部声明了对应的变量，但是并不赋值。

实参：

- 概念：实际上的参数。调用函数时传递的参数，实参将会传递给函数中对应的形参。
- 在调用函数时，可以在函数的 ()中指定实参。
- 实际参数和形式参数的个数，一般要相同。
- 如果实参的数量少于形参的数量，多余的形参会被定义为 `undefined`
- 如果实参的数量多余形参的数量，多余实参不会被赋值。
- 实参可以是任意数据类型，当需要传递的实参过多时，可以封装到对象中传递。

在 JS 中，形参的默认值是 `undefined`。

### 函数的返回值

- 可以使用return来设置函数的返回值，语法：`return 值;`
- `return`后的值将作为函数的执行结果返回
- 定义一个变量来接收该结果
- 在函数中，`return`后的语句都不再执行
- 如果函数中不写return或者return后面不写值，都返回`undefined`
- 返回值可以是任意的数据类型
- `return` 只能返回一个值。如果用逗号隔开多个值，则以最后一个为准
- fn代表的是整个函数，而fn()代表的是返回值。

### 枚举对象中的属性

for...in语句，对象中有几个属性，循环体就会执行几次，每次执行时，会将对象中的属性的名字赋值给变量。

````js
        for(var n in obj){
            console.log(`属性名${n}`);
            console.log(`属性值${obj[n]}`);
        }
````

### 作用域

作用域指一个变量作用的范围，在JS中有两种作用域：

- 全局作用域
  - 直接编写到script标签中的JS代码，都在全局作用域
  - 全局作用域在页面打开时创建，关闭时销毁
  - 在全局作用域中有一个全局对象window，代表浏览器的窗口，由浏览器创建，我们可以直接使用
  - 在全局作用域中，我们创建的变量都会作为window对象的属性保存
  - 创建的函数会作为window对象的方法保存
  - 全局作用域中的变量都是全局变量，在页面的任意部分都可以访问

- 函数作用域
  - 调用函数时创建函数作用域，函数执行完毕后，函数作用域销毁
  - 每调用一次函数就会创建一个新的作用域，他们是相互独立的
  - 在函数作用域中可以访问到全局作用域的变量
  - 全局作用域无法访问到函数作用域的变量
  - 当在函数作用域中操作变量时，会先在自身作用域中寻找，有就直接使用，没有则向上一级作用域寻找。直到全局作用域，没找到就报错
  - 在函数中访问全局的变量可以使用window对象
  - 在函数作用域中也有声明提前，使用var和function都会声明提前
  - 在函数作用域中不使用var声明的变量都会称为全局变量
  - 定义形参相当于在函数作用域中声明了变量

### 变量的声明提前

使用var关键字声明的变量，会在所有的代码执行前被声明（但是不会被赋值）。但是如果声明变量时不使用var关键字，变量不会声明提前。

函数的声明提前

- 使用函数声明创建的函数`function fun(){}`，会在所有的代码执行之前就被创建，我们可以在函数声明前调用函数。
- 使用函数表达式创建的函数`var fun = function(){}`不会声明提前

### debug

- 断点调试
- 监控

### this

解析器（浏览器）在调用函数时，每次都会向函数内部传递进一个隐含的参数，这个隐含的的参数就是this。

- this指向一个对象，这个对象我们称为函数的执行上下文对象
- 根据函数的调用的方式不同，this会指向不同的对象
- 以函数的形式调用时，this永远都是window
- 以方法的形式调用时，this就是调用这个方法的对象
- 以构造函数的形式调用时，this就是实例，即`var per = new Penson();`的`per`
- 以call()和apply()调用时，this是指定的那个对象，即`fun.call(obj1)和fun.apply(obj2);`中的obj1和obj2
- 在事件的响应函数中，响应函数是给谁绑定的，this就是谁，即`btn.onclick = function () {console.log(this);}`，此时，this是btn

### arguments

调用函数时的隐含参数除了this还有arguments

- arguments是封装实参的对象
- 是一个类数组对象，它也可以通过索引操作数据，获取长度
- 在调用函数时，我们所传递的实参都会在arguments中保存
- arguments.length可以获取实参的长度
- 我们即使不定义形参，也可以通过arguments来使用实参
- `arguments[0]、arguments[1]`分别表示第一个，第二个实参
- `arguments.callee`这个属性对应一个函数对象，就是当前正在指向的函数的对象
- `arguments.callee ===fun // true`

### 工厂模式创建对象

使用工厂方法创建对象，通过该方法可以大批量创建对象.

- 创建一个函数
- 函数里创建一个新的对象
- 对象里添加属性
- 将新的对象通过return作为函数值返回
- 从外面传递参数

这种方法使用的构造函数都是Object，所以创建的对象都是Object这个类型，就导致我们无法区分多种不同类型的对象。

### 构造函数创建对象

- 创建一个构造函数，专门创建Person对象（Penson类）
- 构造函数就是一个普通的函数，创建方式和普通函数没什么区别
- 不同的是构造函数习惯首字母大写
- 构造函数和普通函数的区别就是调用的方式不同
- 普通函数直接调用，构造函数需要使用new关键字调用`var per = new Penson;`
- 使用同一类构造函数创建的对象，我们称为一类对象，也将一个构造函数称为一个类（Person类），创建的对象称为该类的实例，或者该构造函数的实例。`per是Person类的实例`

构造函数的执行流程：

- 立即创建一个新的对象
- 将新建的对象设置为函数的this，在构造函数中可以使用this来引用新建的对象
- 逐行执行函数中的代码
- 将新建的对象作为返回值返回

通过instanceof可以检查一个对象是否是一个类的实例

- `对象 instanceof 构造函数`
- 是则返回true，不是则返回false

所有的对象都是Object构造函数的实例

将函数定义在全局作用域中，会污染全局作用域的命名空间，也很不安全。

JavaScript 的构造函数中可以添加一些成员，可以在构造函数本身上添加，也可以在构造函数内部的 this 上添加。通过这两种方式添加的成员，就分别称为静态成员和实例成员。

- 静态成员：在构造函数本上添加的成员称为静态成员，只能由构造函数本身来访问。
- 实例成员：在构造函数内部创建的对象成员称为实例成员，只能由实例化的对象来访问。

### 原型（prototype）

创建的每一个函数，解析器都会向函数中添加一个prototype属性，这个属性对应一个对象，这个对象就是原型对象。

- 如果函数作为普通函数调用prototype没有任何作用
- 当函数作为构造函数调用时，它所创建的对象中都会有一个隐含的属性，指向该构造函数的原型对象。我们可以通过__proto__来访问该属性
- 原型对象就相当于一个公共的区域，所有同一类的实例都能访问到这个对象
- 可以将对象的共有属性，统一设置到原型对象中
- 当我们访问对象的属性或者方法时，会先在对象自身中寻找，有就使用，没有则会在原型对象中寻找，还没有就去原型的原型中寻找，直到找到Object对象的原型，Objecet对象的原型没有原型，还没有就返回undefined，称为**原型链**
- 创建构造函数时，可以将对象中共有的属性和方法，统一添加原型中
- 使用in检查对象中是否含有某个属性会检查原型，检查自身使用`hasOwnProperty('')`检查对象

### 垃圾回收

当一个对象没有任何一个变量或属性对它进行引用，此时我们永远无法操作该对象，此时，这种对象就是一个垃圾。这种对象过多会占用大量内存空间，导致程序变慢，这种垃圾必须进行清理。

JS中有自动的垃圾回收机制，会自动将这些垃圾对象从内存中销毁，我们不需要进行垃圾回收。

垃圾回收(GC)，将对象设置为null即可，浏览器会自动处理

````js
var obj = new Object();
obj = null;
````

## 数组（Array）

数组是一个对象，数组是使用数字作为索引操作元素。索引(index)，从0开始的整数叫做索引。对象使用属性名，数字使用索引。数组的存储性能比一般对象要好，在开发中经常使用数组来存储数据。

- 创建数组
  - `var arr = new Array();`
  - 可以在创建时指定元素，用,隔开
  - `var arr = new Array(1,2,3)`
  - 如果只传一个参数，标识数组的长度
  - `var arr = new Array(10)//长度为10的空数组`
- 添加属性
  - `数组[index] = 值;`
- 读取属性
  - `数组[索引]`
- 使用`length`获取或者设置数组的长度
  - `arr.length`
  - `length=max(index)+1`
  - 如果修改的length>原长度，多的位置会空出来
  - 如果修改的length<原长度，少的位置会被删除
- 使用`arr.length`可以向数组的最后添加元素
- 尽量不要创建非连续的数组

### 数组字面量

使用数组字面量创建数组

- `var arr = [];`

使用字面量创建数组时，也可以在创建时就指定数组的元素。

- `var arr = [10]//表示创建一个数组只有元素10`
- `var arr = new Array(10)//长度为10的空数组`
- 数组里可以放数组，这样的数组称为二维数组。

### 数组的方法

- push();
  - 像末尾添加一个或多个元素，并返回数组的新长度
  - 会改变原数组
- pop();
  - 删除最后一个元素，并返回被删除的元素
  - 会改变原数组
- unshift();
  - 向开头添加一个或多个元素，并返回数组的新长度
  - 向前插入元素后，其他元素索引会依次调正
  - 会改变原数组
- shift();
  - 删除第一个元素，并返回被删除的元素
  - 会改变原数组
- slice();
  - 从数组中提取指定的一个或多个元素，返回新的数组
  - `新数组 = 原数组.slice(开始位置的索引, 结束位置的索引); //注意：包含开始索引，不包含结束索引`
  - 传递一个负值，表示从后往前计算
  - 不会改变原数组
- splice();
  - 从数组中删除指定的一个或多个元素，也可以替换和插入元素
  - 会改变原数组
- concat();
  - 可以连接一个或多个数组，并将新的数组返回
  - 不会改变原数组
- join();
  - 将数组转换成字符串
  - 不会改变原数组，将转换后的字符串作为结果返回
  - 可以指定一个字符串作为参数，这个字符串将成为数组元素的连接符，默认是`,`
- reverse();
  - 反转数组，返回的结果为反转后的数组
  - 会改变原数组
- sort();
  - 对数组的元素默认按照Unicode编码，从小到大排序
  - 可以自己指定排序规则
  - 添加一个回调函数
  - 回调函数需要定义两个形参
  - 浏览器将会使用数组中的元素作为实参去调回调函数
  - 会改变原数组

````js
        arr2.sort(function(a,b){
          return a-b;//升序排列，b-a降序排列
        })
````

### 数组的遍历

遍历数组就是将数组中所有的元素都取出来。

````js
        for(var i = 0; i<arr.length ; i++){
            console.log(arr[i]);
        }
````

- 一般都是使用for循环遍历数组，JS提供`forEach()`方法遍历数组
- `forEach()`需要一个函数作为参数
- `arr.forEach(function(value,index,obj){});`
- 像这种函数，由我们创建但是不由我们调用的，称为回调函数。
- 数组中有几个元素，函数就会执行几次，每次执行时，浏览器会将遍历到的元素以实参的形式传递进来，我们可以定义形参读取这些内容。
- 浏览器会在回调函数中传递3个参数
  - 第一个参数value：当前正在遍历的元素
  - 第二个参数index：当前正在遍历元素的索引
  - 第三个参数obj：正在遍历的数组
- IE8以下，这种方法不兼容

ES6 中，如果我们要遍历一个数组，可以这样做

````js
        let arr1 = [2, 6, 8, 5];

        for (let value of arr1) {
            console.log(value);
}
````

- for ... of获取的是数组里的值；如果采用for ... in遍历数组，则获取的是 index 索引值
- for ... in主要用于遍历对象，不建议用来遍历数组
- `for (const 变量 in 对象) {}`
- for ... of 的循环可以避免我们开拓内存空间，增加代码运行效率，使用 for…of 遍历数组比较好

### 函数的方法

- call()和apply()这两种是函数对象的方法，需要通过函数对象来调用
- 当对函数调用call()和apply()都会调用函数执行
- `fun.call()`、`fun.apply()`、`fun()`
- 在调用call()和apply()可以将一个对象指定为第一个参数
- 此时这个对象，将会成为函数执行的this
- call()方法可以将实参在对象之后依次传递
- apply()方法需要将实参封装都一个数组中传递

## Date对象

在JS中使用Date对象来表示时间

- 创建Date对象
  - `var date = new Date();`
  - 直接使用构造函数创建的Data对象，则会封装当前代码执行的时间
  - 可以将一个时间作为参数传递给构造函数
  - `var date = new Date('12/30/2020 12:13:58')`
- date.getDate();
  - 获取当前日期是几日
- date.getDay();
  - 获取当前日期是周几，0-6，0代表周日
- date.getMonth();
  - 获取月份，0-11，0表示1月，11表示12月
- getTime();
  - 获取当前日期对象的时间戳
  - 从1970年1月1日，0时0分0秒到当前时间花费的毫秒数，1秒=1000毫秒
  - 计算机底层就是使用时间戳
  - `Date.now()`获取当前时间的时间戳，可以测试代码执行的性能

## Math对象

- Math和其他对象不同，不是一个构造函数
- 它属于工具类，不用创建对象，里面封装了数学运算相关的属性和方法
- `Math.abs()`绝对值
- `Math.ceil()`上舍入，进行向上取整
- `Math.floor()`向下取整
- `Math.round()`四舍五入
- `Math.random()`可以生成随机0-1的随机数
- 生成x-y随机数：`Math.round(Math.random()*(y-x)+x)`
- `Math.max()`获取最大值
- `Math.min()`获取最小值
- `Math.pow(x,y)`x的y次幂
- `Math.sqrt(x)`对一个数开方

## 包装类

在JS中为我们提供了3个包装类，通过这3个包装类可以将基本的数据类型装换成对象。

- String()
  - 可以将基本数据类型字符串转换成String对象
- Number()
  - 可以将基本数据类型的数字转换成Number对象
- Boolean()
  - 可以将基本数据类型的布尔值转换成Boolean对象
- 在实际应用中，不会使用基本数据类型的对象，浏览器底层会自己使用
- 方法和属性只能添加给对象，不能添加给基本数据类型，当我们对一些基本数据类型调用属性和方法时，浏览器会临时使用包装类将其转换成对象，然后再调用对象的属性和方法，调用完后，再将其装换成基本的数据类型。

## 字符串的方法

在计算机底层，字符串是以字符数组的形式保存的。

- `indexOf(想要查询的字符串)`检索字符串中是否含有指定内容，找到返回索引，没有返回-1
- `charAt()`根据索引获取指定索引的字符，直接写`[]`也可以
- `charCodeAt()`获取索引处的Unicode编码
- `String.fromCharCode()`根据Unicode编码获取
- `concat`和`+`一样
- `slice()`可以在字符串中截取指定内容
- `substring()`截取字符串，不同的是这个方法不能接受负值，默认使用0，会自动交换
- `splice()`删除指定的一个或多个元素
- `split()`可以将字符串拆分成一个数组，传递一个字符串作为参数，根据该字符串拆分数组
- `toUpperCase()`将字符串转换成大写并返回
- `toLowerCase()`将字符串装换成小写并返回

## 正则表达式

- 正则表达式用于定义一些字符串的规则。
- 计算机可以根据正则表达式，来检查一个字符串是否符合指定的规则，或者将字符串中符合规则的内容提取出来。

### 创建正则表达式对象

#### 使用构造函数创建正则表达式的对象

- `var 变量 = new RegExp("正则表达式","匹配模式") //两个参数都是字符串`
- `test()`这个方法可以检查一个字符串是否符合正则表达式的规则
- `reg.test(str)`如果符合则返回true，否则返回false
- 构造函数第二个参数，两个参数都是字符串
  - i 忽略大小写，ignore
  - g 全局匹配模式，global
  
#### 使用字面量创建正则表达式

- `var 变量 = /正则表达式/匹配模式;  // 注意，这个语法里没有引号`

两种方法的比较：

- 构造函数创建时，更加灵活，因为参数中可以传递变量
- 使用字面量创建更加简单

全局匹配g慎用test()方法:

- 对于全局的正则表达式，test()只会检测是否存在某个目标字符串，只要存在就为true

````js
        const reg = /test/g;
        const str = '_test_test';

        console.log(reg.test(str)); // true
        console.log(reg.lastIndex); // 5

        console.log(reg.test(str)); // true
        console.log(reg.lastIndex); // 10

        console.log(reg.test(str)); // false
        console.log(reg.lastIndex); // 0
````

- 全局匹配模式g一般用 exec()、match()、replace()等方法。
- 全局匹配模式g如果用于test()方法会有问题。因为g模式会生成一个lastindex参数来存储匹配最后一次的位置。

- 创建一个表达式，检查字符串是否有a或b，使用`|`或者`[]`
  - `var reg = /a|b/`
  - `var reg  = /[ab]/`
  - `var reg = /[a-z]/`任意小写
  - `var reg = /[A-Z]/`任意大写
  - `var reg = /[A-z]/`任意字母
  - `var reg = /a[bde]c/`
- `^`表示除了
  - `var reg = /[^ab]/`除了a或b之外，还有没有其他的字符内容
  - `var reg = /[^0-9]/`除了数字，还有没有其他的字符内容

### 字符串和正则表达式的方法

- `split()`可以将一个字符串拆分成一个数组
  - 该方法可以根据任意字母将字符串拆分
  - 可以传递正则表达式作为参数，这样方法可以根据正则表达式区拆分字符串
  - `str.split(/[a-z]/)`
- `search()`可以搜索字符串是否含有指定内容
  - 如果搜索到指定内容，则会返回第一次出现的出现的索引，没有则返回-1
  - 可以传递正则表达式作为参数
  - `str.search(/a[bcd]e/)`
- `match()`可以根据正则表达式，从一个字符串中符合条件的内容提取出来
  - `str.match(/[A-z]/)`默认情况下，match只会只找到第一个
  - 我们可以设置正则表达式为全局匹配
  - `str.match(/[A-z]/g)`也可以设置同时设置ig
  - match()方法会将匹配到的内容封装到一个数组中返回，即使只查询到一个结果
  - match()这个方法还是很实用的，可以在一个很长的字符串中，提取出有规则的内容。爬虫的时候经常会使用
- `replace()`可以将字符串中的指定内容替换成新的内容
  - `str.replace('a','@')`2个参数，被替换的内容和新的内容，默认只会替换第一个
  - `str.replace(/[a-z]/ig,'@')`
  - `str.replace(/[a-z]/ig,'')`可以去除字母

### 正则表达式语法

- 创建正则表达式检查字符串是否含有aaa
  - `var reg = /a{3}/`
  - `{n}`表示正好出现n次
  - `{m,n}`表示出现m次到n次
  - `{m,}`表示出现m次以上
  - `()`表示一组
- 量词
  - `+`表示至少一个，相当于`{1，}`
  - `*`表示0或多个，相当于`{0,}`
  - `?`表示0或1，相当于`{0,1}`
- 检查字符串是否以a开头
  - `var reg = /^a/`
  - `^`表示开头，中括号里面表示除了/[^a]/
  - `var reg = /a$/`
  - `$`表示结尾
  - `/^a$/`表示只有a
  - 如果在正则表达式中同时使用^和$符号，则要求字符串必须完全符合正则表达式。
  
- 检查字符串是否是合法手机号
  - `var reg = /^1[3-9][0-9]{9}$/`
- 检查字符串中是否含有.
  - `.`有特殊意义，表示任意字符
  - 此时需要使用转义字符，`\`，字符串中`\`也是表示转义
  - `var reg = /\./`
  - `\.`表示单纯的`.`
- `\w`任意字母、数字、_  相当于`[A-z0-9_]`
- `\W`除了字母、数字、_  相当于`[^A-z0-9_]`
- `\d`任意数字，[0-9]
- `\D`除了数字，[^0-9]
- `\s`空格
- `\S`除了空格
- `\b`单词边界 `var reg = /\bhello\b/`
- `\B`除了单词边界
- 去除字符串前后的空格
  - 去除空格就是就是使用`''`替换空格
  - `str.replace(/^\s*/,"')`去掉开头的空格
  - `str = str.replace(/\s*$/, "")`去除结尾的空格
  - `str = str.replace(/^\s*|\s*$/g,"")`去除开头结尾空格
- 判断字符串是否为电子邮件
  - `var emailReg = /^\w{3,}(\.\w+)*@[A-z0-9]+(\.[A-z]{2,5}){1,2}$/`

## 高阶函数

当函数A接收函数B作为参数，或者把函数C作为返回值输出时，我们称函数A为高阶函数。高阶函数是对其他函数进行操作的函数。

- 把其他函数作为参数

````js
        function fn1(a,b,f){
            console.log(a+b);
            f && f();
        }
        fn1(10,20,function(){
            console.log('我是一个函数')
        })
````

- 把其他函数作为返回值
  
````js
        function fn1(){
            let a = 20;
            return function(){
                console.log(a);
            };
        }
        const foo = fn1();
        foo();
````

变量a是函数内的局部变量，所以外部无法访问。

## 闭包

- 有权访问另一个函数作用域中变量的函数称为闭包。
- 闭包是一种函数，闭包是一种现象。
- 这个作用域可以访问另一个函数内部的局部变量，就产生了闭包（这时理解为一种现象），另外那个作用域所在的函数称之为闭包函数。
- 强调的是访问局部变量

````js
        function fn1() {
            let a = 10;

            function fn2() {
                console.log(a); //在 chrome 浏览器控制台中，设置断点，可以调试闭包Closure
            }
            fn2();
        }

        fn1();
````

- 函数fn2的作用域访问了fn1中的局部变量，此时，fn1中就产生了闭包，fn1称之为闭包函数。
- 一般来说，在 fn1 函数执行完毕后，它里面的变量 a 会立即销毁
- 由于产生了闭包，所以 fn1 函数中的变量 a 不会立即销毁，因为 fn2 函数还要继续调用变量 a
- 只有等所有函数把变量 a 调用完了，变量 a 才会销毁。
- 闭包的主要作用就是：延伸了变量的作用范围。

## 面向过程和面向对象

面向过程：先分析号具体的步骤，然后按照步骤，一步步解决问题。

- 优点：性能比面向对象高，史和跟硬件联系紧密的东西，例如单片机就是采用面向过程编程
- 缺点：没有面向对象易维护、易复用、易拓展

面向对象：以对象功能来划分问题，而不是步骤。

- 优点：面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，更加灵活，易于维护

面向对象的编程思想：对代码和数据进行封装，并以对象调用的方式，对外提供统一的调用接口。

- 开车时，无需关心汽车内部构造多复杂，对大多数人来说，只需要会开，知道有哪些功能就行了

面向对象的特性：在面向对象程序开发思想中，每一个对象都是功能中心，具有明确分工，面向对象编程适合多人合作。

JS中的面向对象，是基于原型的面向对象。ES6中，新引入了类(Class)和继承(Extends)来面向对象。

JS中的对象(Object)是依靠构造器(constructor)和原型(prototype)构造出来的。

## JSON介绍

JSON(Javascript Object Notation)（javascript对象表示形式）和对象字面量很像。

- JSON的属性必须使用双引号引起来，对象字面量可以省略
- 注：json 里一般放常量、数组、对象等，但很少放 function
- 对象和 json 没有长度，json.length 的打印结果是 undefined
- 不能使用for循环遍历
- json 采用 for...in...进行遍历，和数组的遍历方式不同

## 浅拷贝和深拷贝

- 浅拷贝：只拷贝最外面一层的数据，更深层次的对象，只拷贝引用
- 深拷贝：拷贝多层数据，每一层级别的数据都会拷贝
- 拷贝引用时，属于传址，而非传值
- 深拷贝会把对象里所有的的数据重新复制到新的内存空间，是最彻底的拷贝

### 浅拷贝的实现方式

- 用for in 实现浅拷贝

````js
        var obj1 = {
            a : 1,
            b :'2',
            f:{
                name:'haha'
            }
        };
        var obj2 = {};
        for(var key in obj1){
            obj2[key] = obj1[key];
        }
        console.log(obj1);
        console.log(obj2);
        obj1.a = 999;
        obj1.f.name='hehe';//修改obj1的属性
        console.log(obj1);
        console.log(obj2);
````

在 obj2 中， a 和 b 这两个属性会单独存放在新的内存地址中，和 obj1 没有关系，但是 obj2.f 属性还是和 obj1.f 指向同一个堆内存地址

- 用 Object.assgin() 实现浅拷贝（ES6新语法，推荐的方式）
- 语法1`obj2 = Object.assgin(obj2, obj1);`
- 语法2`Object.assign(目标对象, 源对象1, 源对象2...);`
- `const obj2 = Object.assign({}, obj1);`
- `Object.assign(obj2,obj1);`相当于常量中的`obj2=obj1`
- 将obj1 拷贝给 obj2。执行完毕后，obj2 的值会被更新，如果对象里的属性名相同，会被覆盖
- Object.assign() 可以将多个“源对象”拷贝到“目标对象”中

````js
    const myObj = {
        name: '法外狂徒张三',
        age: 17,
    };

    // 【写法1】浅拷贝：把 myObj 拷贝给 obj1
    const obj1 = {};
    Object.assign(obj1, myObj);

    // 【写法2】浅拷贝：把 myObj 拷贝给 obj2
    const obj2 = Object.assign({}, myObj);

    // 【写法3】浅拷贝：把 myObj 拷贝给 obj31。注意，这里的 obj31 和 obj32 其实是等价的，他们指向了同一个内存地址
    const obj31 = {};
    const obj32 = Object.assign(obj31, myObj);
````

### 深拷贝的实现方式

深拷贝其实就是将浅拷贝进行递归。

- 用 for in 递归实现深拷贝

````js
        var obj1 = {
            a: 1,
            b: '2',
            f: {
                name: 'haha'
            },
            color: ['red', 'blue', 'green']
        };
        var obj2 = {};
        deepCopy(obj2, obj1);
        console.log(obj2);
        obj1.f.name = 'hehe';
        console.log(obj1);
        console.log(obj2);
        function deepCopy(newObj, oldObj) {
            for (let key in oldObj) {
                //let item = oldObj[key];
                if (oldObj[key] instanceof Array) {
                    newObj[key] = [];
                    deepCopy(newObj[key], oldObj[key]);
                } else if (oldObj[key] instanceof Object) {
                    newObj[key] = {};
                    deepCopy(newObj[key], oldObj[key]);
                } else {
                    newObj[key] = oldObj[key];
                }
            }
        }
````

## 事件的简介

用户和浏览器之间的交互行为。点击某个元素、鼠标移动，关闭弹窗等等。

JavaScript是以事件驱动为核心的语言。js和html之间的交互是通过事件实现的。

我们可以在事件对应的属性中，设置一些JS代码，当事件被触发时，这些代码将会执行。

事件的三要素：事件源、事件、事件驱动程序

- 网页上弹出一个广告，我点击右上角的X，广告就关闭了。这件事情里，事件源是：X。事件是：onclick。事件驱动程序是：广告关闭了。
- 谁引发的后续事件，谁就是事件源。

1. 获取事件源：`document.getElementById("box");
2. 绑定事件：`事件源.事件 = function(){事件的驱动程序}`
   - box.onclick = function(){alert("box被点击")};
3. 书写事件驱动程序：关于DOM的操作

## DOM

Javascript基础分为3个部分：

- ECMAScript:JavaScript的语法标准，包括变量、表达式、运算符、函数、if语句、for语句。
- DOM：文档对象模型(Document  Object Model)，操作网页上的元素的API。比如让盒子移动、变色、轮播图等。
- BOM：浏览器对象模型(Browser Object Model)，操作浏览器部分功能的API。比如让浏览器自动滚动。

JS通过DOM来对HTML文档进行操作，只要理解DOM就可以操作WEB页面。

- Document文档：文档表示整个HTML网页文档。
- Object对象：将网页中每一个部分都转换成了对象，网页中的标签、文本、注释都是对象。

- Model模型：使用模型来表示对象之间的关系，这样方便我们获取对象。

### 解析过程

HTML加载完毕，渲染引擎会在内存中把HTML文档生成一个DOM树，getElementById是获取内中BOM上的元素节点。然后操作的时候修改该元素的属性。DOM的作用：

- 找对象（元素节点）
- 设置元素的属性值
- 设置元素的样式
- 动态创建和删除元素
- 事件的触发响应：事件源、事件、事件的驱动程序

### 节点

节点(node)：构成元素HTML网页的最基本单元。网页中的每一个部分都可以称为一个节点，比如：HTML标签、属性、文本、注释、整个文档都是一个节点。

节点的分类：

- 文档节点（文档）：整个HTML文档。
- 元素节点（标签）：HTML标签。
- 属性节点（属性）：元素的属性。
- 文本节点（文本）：HTML标签中的文本内容（包括标签之间的空格、换行）。

节点的类型不同，属性和方法也不同，所有的节点都是Object。

节点的属性：

|              | nodeName  | nodeType | nodeValue |
| :----------: | :-------: | :------: | :-------: |
| **文档节点** | #document |    9     |   null    |
| **元素节点** |  标签名   |    1     |   null    |
| **属性节点** |  属性名   |    2     |  属性值   |
| **文本节点** |   #text   |    3     | 文本内容  |

DOM由节点组成，在HTML中，一切都是节点。

### 元素节点的获取

浏览器为我们提供文档节点对象，这个对象是window的属性。可以在页面中直接使用，文档节点代表的是整个网页。

- `console.log(document)` 文档对象
- 通过document对象找到元素节点
- `var div1 = document.getElementById("box1");`通过 id 获取 一个 元素节点（为什么是一个呢？因为 id 是唯一的）
- `var div2 = douument.getElementsByTagName("div")`通过 标签名 获取 元素节点数组，所以有s
  - 这个方法会给我返回一个类数组对象，所有查询的元素都会封装到对象中。
- `var div3 = document.getElementsByClassName("haha")` //方式三：通过 类名 获取 元素节点数组，所以有s，ie8及以下不支持
- 都是通过document调用的

### 浏览器加载顺序

浏览器加载页面是按照从上到下的顺序加载的，如果将script标签写在页面上边，代码执行时，页面还没加载。

- 可以为window绑定一个onload事件，该事件对应的响应函数将会在页面加载完毕后执行
- `window.onload = function(){}`

### DOM查询

- `innerHTML` 这个属性可以获取到元素内部的html代码，对于自结束标签没有意义
- 如果需要读取元素节点属性：`元素.id` `元素.name` `元素.value`
- class属性不能采用这种方式，读取class采用：`元素.className`

获取元素节点的子节点

- `元素.getElementsByTagName('li');`
- `子节点数组 = 父节点.childNodes;`  获取所有子节点。根据DOM，标签中的空白和换行也会当成文本节点。
- `子节点数组 = 父节点.children;` 获取当前元素的所有子元素
- `.innerHTML`和`.innerText`的区别，innerText没有标签，只有文本
- 在事件的响应函数中，响应函数是给谁绑定的，this就是谁

### 获取 html 文档的方法

- `document.title` 获取文档标题
- `document.head` 获取文档的头标签
- `document.documentElement;`获取html根标签
- `document.body;`获取body标签
- `documment.all;`获取页面中所有元素
- `var div = document.querySelector(".box1 div");`这个方法总会返回第一个元素，兼容IE8及以上
- `var div = document.querySelectorAll(".box1 div");`这个方法会返回符合条件的数组，兼容IE8及以上

### DOM的增删改

- `createElement()`创建元素节点
- `createTextNode()`创建文本节点
- `元素.innerHTML="新标签"`
- `appendChild()`把新的子节点添加到指定节点
- `父节点.insertBefore(前节点,后节点)`在指定的子节点前面插入新的子节点
- `父节点.replaceChild(新节点,旧节点)`在指定的子节点前面插入新的子节点
- `父节点.removeChild(新节点,旧节点)` 删除指定节点
- `需要删除的节点.parentNode.removeChild(需要删除的节点);`
- 使用innerHTML也能完成DOM增删改的相关操作
- `父元素.innerHTML += "<li>新标签</li>";` 但是修改的内容较大
- 一般会将两种方法结合使用
- 在响应函数的末尾加`return false;`可以取消默认行为
- `confirm("确认删除吗?")`可以弹出确认取消框

### DOM操作CSS

通过JS修改元素的样式

- 内联样式
  - `元素.style.样式名 = "样式值"`
  - 如果CSS中的样式名中含有`-`，比如`background-color`，需要将这种样式名修改为驼峰命名法,`backgroundColor`
  - `border-top-width`修改为`borderTopWidth`
  - w3cschool中css的参考手册可以查到
  - 通过这种方法设置的样式是内联样式，具有较高的优先级
  - 通过`元素.style.样式名`可以读取内联样式的属性值
  - `元素.style["属性"];`这种方法读取更加灵活
  - 这两种方法返回的属性值都是字符串，并且带单位
- 元素当前显示的样式
  - `元素.currentStyle.样式` 但是这种方法只有IE才能用
  - `getComputedStyle()`这个方法IE9以上及其他浏览器可以使用，这是window的方法，可以直接使用，需要两个参数
    - 需要获取的样式
    - 可以传递一个伪元素，一般都传null
    - 该方法会返回一个对象，对象封装了当前元素对应的样式
    - `getComputedStyle(box1,null).width`
    - 该方法或获取真实的值，而不是默认值，比如宽度，不会获取auto，而是真实的像素值

## JS动画的主要内容

- 三大系列:offset、scroll、client
- 一个事件对象：event(事件被触动时，鼠标和键盘的状态)
- 三大效果：闪现、匀速、缓动
- 三个性值：冒泡、兼容、封装

### offset系列

- `offsetWidth` width + padding + border不包括margin
- `offsetHeight` Height + padding + border不包括margin
- `offsetLeft` 当前元素相对于其包含块的水平偏移量
- `offsetTop`当前元素相对于其包含块的垂直偏移量
  - **从父亲的 padding 开始算起，父亲的 border 不算在内**
- 上面4个方法返回的是数字，不带单位
- 上面4个方法是只读的,`.style`才可以赋值
- `offsetParent`获取当前元素的包含块。

### scroll系列

- `scrollWidth` 获取元素整个滚动区域的宽度。包括 width 和 padding，不包括 border和margin。
- `scrollHeight` 获取元素整个滚动区域的高度。包括 width 和 padding，不包括 border和margin。
- `scrollLeft`获取水平滚动条滚动的距离。
- `scrollTop`获取垂直滚动条滚动的距离。
- 同样上面的方法返回值都是数字，不带单位

- 当某个元素满足scrollHeight - scrollTop == clientHeight时，说明垂直滚动条滚动到底了。
- 当某个元素满足scrollWidth - scrollLeft == clientWidth时，说明水平滚动条滚动到底了。

在谷歌浏览器中，上面的等式似乎有些问题，清除浏览器默认样式后，将`==`改成`<=`，等式才能成立，也可以说明滚动条滚到底。

### client系列

- `clientHeight` 返回元素的可见高度（width + padding）。
- `clientWidth` 返回元素的可见宽度（height + padding）。
- 当body/html 元素调用时，获取的网页可视区域宽度和高度。
- `clientX` 鼠标距离可视区域左侧距离。
- `clientY` 鼠标距离可视区域上侧距离。
- `clientTop` 盒子的上border。
- `clientLeft` 盒子的左border。
- `pageX = clientX + scrollLeft`(IE不支持)
- `pageY = clientY + scrollTop`(IE不支持)

## 事件对象

当事件的响应函数被触发时，会产生一个事件对象event。浏览器每次都会将这个事件event作为实参传递给之前的响应函数。
  
这个对象中，包含了与当前事件相关的一切信息，比如鼠标的坐标、键盘的哪个按键被按下、鼠标滚轮滚动的方向。

- 所有浏览器都支持event对象
- 普通浏览器写法：`event`
- IE8及以下写法：`window.event`
- 兼容的写法：`event = event || window.event;`

事件对象的常用属性：

- `timeStamp`返回事件生成的日期和事件
- `bubbles`返回布尔值，指示事件是否时冒泡事件类型
- `button`返回事件被触发时，哪个鼠标按钮被点击
- `target`该事件被传送到的对象
- `type`事件的类型
- `pageX`和`pageY`光标在该网页的距离
- `clientX`和`clientY`光标在可视区域的距离
- `screenX`和`screenY`光标相对于浏览器的距离

## 事件的冒泡（Bubble）

- 指事件的向上传导，当后代元素上的事件被触发时，其祖先元素的相同事件也会被触发。
- `div -> body -> html -> document -> window`
- 从开发的角度，冒泡多数情况是有用的。
- `event.cancelBubble = true;`可以取消冒泡

## 事件的委派（委托）

- 将事件统一绑定给元素的共同祖先元素，这样当后代元素上的事件触发时，会一直冒泡到祖先元素，通过祖先元素的响应函数来处理事件。
- 事件的委派利用了冒泡的原理，通过委派减少事件的绑定次数，提高程序的性能。
- 如果触发事件的对象是我们期望的元素，则执行,否则不执行。
- event中的target表示触发事件的对象。

## 事件的绑定（注册）

绑定（注册）事件的两种方式：

- `onclick`
  - `element.onclick = functon(){}`
  - `DOM对象.事件 = 函数`的这种绑定事件的方式，一个元素的一个事件只能绑定一个响应函数。绑定多个时，后者会覆盖前者。

- `addEventListener`
  - `element.addEventListener("click",function(){},false);
  - 需要3个参数(IE8及以下不支持)
  - 1：事件的字符串（不要on）
  - 2：回调函数，当事件触发时，该函数会被执行
  - 3：true表示捕获阶段触发，false表示冒泡阶段触发（默认），如果不写，就是默认值。

- `attachEvent`
  - element.attachEvent("onclick",function(){});
  - 需要两个参数（IE8及以下版本浏览器）
  - 1事件的字符串（要on）
  - 2回调函数：当事件触发时，该函数会被执行
  - 注意：执行顺序是，后绑定的先执行。
  - attachEvent()中的this，是window

## 事件的传播

事件的传播有3个阶段：事件捕获、冒泡、目标。

- 事件捕获阶段：事件从祖先元素往子元素查找（DOM树）结构，直到捕获到事件目标target。在这个过程中，默认情况下，事件相应的监听函数是不会被触发的。
  - 捕获顺序`window->document->html->body->父元素、子元素、目标元素`
- 事件目标：当到达目标元素之后，执行目标元素该事件相应的处理函数
- 事件的冒泡阶段：事件从事件目标target开始，从子元素依次触发祖先元素。
  - 冒泡顺序`div->body->html->document`

重点：

- 第一个接收到事件的对象是window
- js中设计到DOM对象时，有两个对象最常用：window、document。它们两个是最先获取到事件的。

## 鼠标事件

鼠标拖拽事件：

- `onmousedown`当鼠标按下时，开始拖拽、
  - 获取`e.pageX - box1.offsetLeft`
  - 获取`e.pageY - box1.offsetTop`
- `onmousemove`当鼠标移动时，元素跟随鼠标移动
  - `box1.style.left = e.pageX - ox + "px";`
  - `box1.style.top = e.pageY - oy + "px";`
- `onmouseup`当鼠标松开时，元素固定在当前位置
  - `document.onmousemove = null;`
  
鼠标滚轮事件：

- `onmousewheel`鼠标滚动的事件，会在滚轮滚动时触发，但是火狐不支持该属性。
- `DOMMouseScroll`在火狐中使用`DOMMouseScroll`。注意该事件需要通过addEventListener()函数来绑定。
- 一般情况下，监听wheelDelta的正负值，就可以确定鼠标滚轮的滚动方向。

````js
    document.addEventListener('mousewheel', function (event) {
              console.log(event.wheelDelta)//向下滚<0
    }, false)
````

- 火狐浏览器鼠标滚轮的信息保存在detail属性里面

````js
    document.addEventListener('DOMMouseScroll',function(event){
              console.log(event.detail)//向下滚>0
    },false)
````

- 通过addEventLister()方法绑定的响应函数，取消默认行为不能使用`return false`，而是使用`event.preventDefault();`

## 键盘事件

- `onkeydown`按键被按下
- `onkeyup`按键被松开
- 键盘事件一般都会绑定给一些可以获取焦点的对象或者document
- 如果一直按住某个键不松手，那么`onkeydown`事件会一直触发。
- 当onkeydown连续触发时，第一次和第二次之间会间隔稍微长一点，后续的间隔会非常快。这种设计是为了防止误操作的发生。

判断键盘哪个键被按下：

- `altKey`返回当事件被触发时，"ALT" 是否被按下。
- `shiftKey`返回当事件被触发时，"SHIFT" 键是否被按下
- `ctrlKey`返回当事件被触发时，"CTRL" 键是否被按下
- 如果按下则返回true，否则返回false。

通过event事件对象的key来获取按键。（keycode已弃用）

- `event.key`直接返回按键的字符串

在文本框中输入内容，属于onkeydown中默认行为，如果使用`return false`，则文本框不能输入内容。

## BOM

浏览器对象模型（Browser Object Model），操作浏览器部分功能的API。比如让浏览器自动滚动。

- BOM可以让我们通过JS来操作浏览器。
- BOM为我们提供了一些对象，来完成对浏览器的操作。

常用的BOM对象：

- `window`代表整个浏览器窗口，同时该对象也是网页中的全局对象。
- `navigator`代表当前浏览器的信息，通过该对象可以识别不同的浏览器。
- `location`代表当前浏览器的地址栏信息，通过该对象可以获取地址栏信息，或者操作浏览器跳转页面。
- `history`代表浏览器的历史记录，通过该对象可以操作浏览器的历史记录。
  - 由于隐私原因，该对象不能获取到具体的历史记录，只能操作浏览器向前或向后翻页
  - 该操作只在当次访问时有效。
- `screen`代表用户的屏幕信息，通过该对象可以获取到用户显示器的相关信息。

这些对象都是作为`window`对象的属性保存的，可以通过`window`对象来使用，也可以直接使用。

### navigator

`navigator.userAgent`可以获取浏览器的信息。

- 我们还可以在电脑浏览器的控制台里可以添加很多设备，通过这种方式，可以模拟移动端浏览器的场景。
- 打开控制台->切换成移动端->点击edit编辑userAgent

### history

- `history.length`获取浏览器历史列表中的 url 数量。注意，只是统计当次的数量，如果浏览器关了，数量会重置为1。
- `history.back();`用来回退到上一个页面，作用和浏览器的回退按钮一样。
- `history.forward();`用来跳转下一个页面，作用和浏览器的「前进按钮」一样。
- `history.go( int n);`需要整数作为参数。
  - 向前/向后跳转n个页面
  - n>0，向前跳转n个页面
  - n=0，刷新当前页面
  - n<0，向后跳转n个页面

### location

- `location.href`获取当前页面的 url 路径（或者设置 url 路径）
  - `location.href = 'https://www.xxx.com';`设置 url 路径

- `location.assign(str);`用来跳转到其他的页面，作用和直接修改`location.href`一样。
  
- `location.reload();`用于重新加载当前页面，作用和「刷新按钮」一样。
  - 在该方法的参数中传递一个true，则会强制清空缓存刷新页面。

- `location.replace();`使用一个新的页面替换当前页面，调用完毕也会跳转页面。但不会生成历史记录，不能使用「后退按钮」后退。

## 定时器

- `setInterval()`循环调用。将一段代码，每隔一段时间执行一次。（循环执行）
- `setTimeout()`延时调用。将一段代码，等待一段时间之后再执行。（只执行一次）。
- 在实际开发中，两者可以根据需要，相互替代。

### setInterval()和clearInterval()

`setInterval()`循环调用。每隔一段时间执行一次，需要两个参数：

- 参数1：回调函数，该函数会每隔一段时间被调用一次。
- 参数2：每次调用间隔的时间，单位是毫秒。
- `setInterval(function(){},1000)`

返回值：返回一个Number类型的数据。这个数字用来作为定时器的唯一标识，方便用来清除定时器。

- `clearInterval(返回值)`可以关闭定时器。
- 返回值可以是任何的参数，如果参数不是一个有效值，则什么都不做。

### setTimeout()和clearTimeout()

`setTimeout()`延时调用，等待一段时间之后再执行。（只执行一次），需要两个参数：

- 参数1：回调函数，等待的间隔时间结束后开始调用。
- 参数2：调用等待的间隔时间，单位是毫秒。

clearTimeout()可以关闭定时器。

### 定时器问题

定时器切换图片练习：通过按钮绑定的定时器，我们每点击一次，就会开启一个定时器，点击多次就会开启多个定时器，就是让定时器速度叠加，并且我们只能关闭最后一次开启的定时器。

- 解决方法：在开启定时器之前，在上一个定时器关闭。
- 延时调用和和定时调用可以相互切换。

## 类的操作

通过style属性来修改元素的样式，每修改一个样式，浏览器需要重新渲染一次页面，这样的执行性能是比较差的，而且当需要修改多个样式时，也不太方便。

- 可以通过修改元素的class属性来间接的修改样式。
- 只修改一次，即可同时修改多个样式。
- 浏览器只需要渲染一次页面，性能比较好。
- 使表现和行为进一步分离。

## JSON

JSON(JavaScript Object Notation)JS对象表示法。

- JS中的对象只有JS自己认识，其他语言不认识。
- JSON就是一个特殊格式的字符串，这个字符串可以被任意语言所识别。
- 并且可以转换为任意语言中的对象。
- JSON在开发中主要用来数据的交互。
- JSON和对象的格式一样，不过JSON字符串中的属性名必须加双引号。

JSON分类：

- 对象{}，不能使函数对象
- 数组[]

JSON中允许的值：

- 字符串
- 数值
- 布尔值
- null
- 对象
- 数组

将JSON字符串转换成JS中的对象

- 在JS中提供了一个工具类，叫做JSON。
- 这个对象可以将JSON和JS对象相互转换。
- `JSON.parse()`
  - 可以将JSON字符串转换成JS对象。
  - 需要一个JSON字符串作为参数，会将该JSON字符串装换成对象。
- `JSONstringify()`
  - 可以将一个JS对象转换成JSON字符串。
  - 需要一个JS对象作为参数，会返回一个JSON字符串。
