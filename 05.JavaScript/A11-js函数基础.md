# 函数基础

函数（Function）：特殊的对象，可以执行。

## 1、函数的概念

- 实现特定功能的多条语句的封装体
- 只有函数是可以执行的

- 函数也是对象
- 函数中可以封装一些功能（代码），在需要时可以只写这些功能和代码
- 可以将要封装的的代码以**字符串的形式**传递给构造函数
- 封装的代码不会立即执行
- 函数代码会在函数调用的时候执行，
- 所有的函数，都是 Fuction 的“实例”（或者说是“实例对象”）。函数本质上都是通过 new Function 得到的。
- 函数既然是实例对象，那么，函数也属于“对象”。

## 2、创建函数对象

1. 以构造函数的方式创建函数：

   - `var fun = new Function();`
   - 实际开发中，不会使用这种方式

2. 使用函数声明来创建函数：

   ````js
           function 函数名([形参1,形参2...形参N]){  
             语句...
           }
   ````

   ````js
           function fun1(a, b){
             return a+b;
           }
   ````

   - 备注：语法中的中括号，表示“可选”

3. 函数表达式（匿名函数）

   ````js
           var 变量名  = function([形参1,形参2...形参N]){
             语句....
           }
   ````

   ````js
           var fun2 = function() {
             console.log("我是匿名函数中封装的代码");
           };
   ````

## 3、函数的调用

- 普通函数的调用，语法：`函数();`或者`函数名.call();`。

```js
	fun()
```

- 通过对象的方法来调用，如果一个函数是作为一个对象的属性保存，那么，我们称这个函数是这个对象的方法。

```js
	obj.fun()
```

- 立即执行函数

````js
        (function (){
            console.log('匿名函数')
        })();
````

- 通过构造函数来调用

```
	new fun()
```

- 临时将一个函数作为指定对象的方法调用

```
	fun.call/apply(obj)
```

apply与call的唯一**区别**就是：**调用apply方法时的参数，实参应该是以数组的形式来书写**。

- 绑定事件函数
- 定时器函数

````js
    let num = 1;
   setInterval(function () {
       num ++;
       console.log(num);
   }, 1000);
````

## 4、形参和实参

形参：

- 形式上的参数。定义函数时传递的参数，当时并不知道是什么值。
- 定义函数时，可以在函数的()中来指定一个或多个形参。
- 多个形参之间使用,隔开，声明形参就相当于在函数内部声明了对应的变量，但是并不赋值。

实参：

- 概念：实际上的参数。调用函数时传递的参数，实参将会传递给函数中对应的形参。
- 在调用函数时，可以在函数的 ()中指定实参。
- 实际参数和形式参数的个数，一般要相同。
- 如果实参的数量少于形参的数量，多余的形参会被定义为 `undefined`
- 如果实参的数量多余形参的数量，多余实参不会被赋值。
- 实参可以是任意数据类型，当需要传递的实参过多时，可以封装到对象中传递。

在 JS 中，形参的默认值是 `undefined`。

## 5、函数的返回值

- 可以使用return来设置函数的返回值，语法：`return 值;`
- `return`后的值将作为函数的执行结果返回
- 定义一个变量来接收该结果
- 在函数中，`return`后的语句都不再执行
- 如果函数中不写return或者return后面不写值，都返回`undefined`
- 返回值可以是任意的数据类型
- `return` 只能返回一个值。如果用逗号隔开多个值，则以最后一个为准
- fn代表的是整个函数，而fn()代表的是返回值。

## 6、作用域

作用域指一个变量作用的范围，在JS中有两种作用域：

- 全局作用域
  - 直接编写到script标签中的JS代码，都在全局作用域
  - 全局作用域在页面打开时创建，关闭时销毁
  - 在全局作用域中有一个全局对象window，代表浏览器的窗口，由浏览器创建，我们可以直接使用
  - 在全局作用域中，我们创建的变量都会作为window对象的属性保存
  - 创建的函数会作为window对象的方法保存
  - 全局作用域中的变量都是全局变量，在页面的任意部分都可以访问

- 函数作用域
  - 调用函数时创建函数作用域，函数执行完毕后，函数作用域销毁
  - 每调用一次函数就会创建一个新的作用域，他们是相互独立的
  - 在函数作用域中可以访问到全局作用域的变量
  - 全局作用域无法访问到函数作用域的变量
  - 当在函数作用域中操作变量时，会先在自身作用域中寻找，有就直接使用，没有则向上一级作用域寻找。直到全局作用域，没找到就报错
  - 在函数中访问全局的变量可以使用window对象
  - 在函数作用域中也有声明提前，使用var和function都会声明提前
  - 在函数作用域中不使用var声明的变量都会称为全局变量
  - 定义形参相当于在函数作用域中声明了变量

## 7、变量的声明提前

使用var关键字声明的变量，会在所有的代码执行前被声明（但是不会被赋值）。但是如果声明变量时不使用var关键字，变量不会声明提前。

函数的声明提前

- 使用函数声明创建的函数`function fun(){}`，会在所有的代码执行之前就被创建，我们可以在函数声明前调用函数。
- 使用函数表达式创建的函数`var fun = function(){}`不会声明提前

## 8、this

解析器（浏览器）在调用函数时，每次都会向函数内部传递进一个隐含的参数，这个隐含的的参数就是this。

- this指向一个对象，这个对象我们称为函数的执行上下文对象
- 根据函数的调用的方式不同，this会指向不同的对象
- 以函数的形式调用时，this永远都是window
- 以方法的形式调用时，this就是调用这个方法的对象
- 以构造函数的形式调用时，this就是实例，即`var per = new Penson();`的`per`
- 以call()和apply()调用时，this是指定的那个对象，即`fun.call(obj1)和fun.apply(obj2);`中的obj1和obj2
- 在事件的响应函数中，响应函数是给谁绑定的，this就是谁，即`btn.onclick = function () {console.log(this);}`，此时，this是btn

## 9、arguments

调用函数时的隐含参数除了this还有arguments

- arguments是封装实参的对象
- 是一个类数组对象，它也可以通过索引操作数据，获取长度
- 在调用函数时，我们所传递的实参都会在arguments中保存
- arguments.length可以获取实参的长度
- 我们即使不定义形参，也可以通过arguments来使用实参
- `arguments[0]、arguments[1]`分别表示第一个，第二个实参
- `arguments.callee`这个属性对应一个函数对象，就是当前正在指向的函数的对象
- `arguments.callee ===fun // true`

## 10、工厂模式创建对象

使用工厂方法创建对象，通过该方法可以大批量创建对象.

- 创建一个函数
- 函数里创建一个新的对象
- 对象里添加属性
- 将新的对象通过return作为函数值返回
- 从外面传递参数

这种方法使用的构造函数都是Object，所以创建的对象都是Object这个类型，就导致我们无法区分多种不同类型的对象。

## 11、构造函数创建对象

- 创建一个构造函数，专门创建Person对象（Penson类）
- 构造函数就是一个普通的函数，创建方式和普通函数没什么区别
- 不同的是构造函数习惯首字母大写
- 构造函数和普通函数的区别就是调用的方式不同
- 普通函数直接调用，构造函数需要使用new关键字调用`var per = new Penson;`
- 使用同一类构造函数创建的对象，我们称为一类对象，也将一个构造函数称为一个类（Person类），创建的对象称为该类的实例，或者该构造函数的实例。`per是Person类的实例`

构造函数的执行流程：

- 立即创建一个新的对象
- 将新建的对象设置为函数的this，在构造函数中可以使用this来引用新建的对象
- 逐行执行函数中的代码
- 将新建的对象作为返回值返回

通过instanceof可以检查一个对象是否是一个类的实例

- `对象 instanceof 构造函数`
- 是则返回true，不是则返回false

所有的对象都是Object构造函数的实例

将函数定义在全局作用域中，会污染全局作用域的命名空间，也很不安全。

JavaScript 的构造函数中可以添加一些成员，可以在构造函数本身上添加，也可以在构造函数内部的 this 上添加。通过这两种方式添加的成员，就分别称为静态成员和实例成员。

- 静态成员：在构造函数本上添加的成员称为静态成员，只能由构造函数本身来访问。
- 实例成员：在构造函数内部创建的对象成员称为实例成员，只能由实例化的对象来访问。

## 12、高阶函数

当函数A接收函数B作为参数，或者把函数C作为返回值输出时，我们称函数A为高阶函数。高阶函数是对其他函数进行操作的函数。

- 把其他函数作为参数

````js
        function fn1(a,b,f){
            console.log(a+b);
            f && f();
        }
        fn1(10,20,function(){
            console.log('我是一个函数')
        })
````

- 把其他函数作为返回值

````js
        function fn1(){
            let a = 20;
            return function(){
                console.log(a);
            };
        }
        const foo = fn1();
        foo();
````

变量a是函数内的局部变量，所以外部无法访问。

## 13、闭包

- 有权访问另一个函数作用域中变量的函数称为闭包。
- 闭包是一种函数，闭包是一种现象。
- 这个作用域可以访问另一个函数内部的局部变量，就产生了闭包（这时理解为一种现象），另外那个作用域所在的函数称之为闭包函数。
- 强调的是访问局部变量

````js
        function fn1() {
            let a = 10;

            function fn2() {
                console.log(a); //在 chrome 浏览器控制台中，设置断点，可以调试闭包Closure
            }
            fn2();
        }

        fn1();
````

- 函数fn2的作用域访问了fn1中的局部变量，此时，fn1中就产生了闭包，fn1称之为闭包函数。
- 一般来说，在 fn1 函数执行完毕后，它里面的变量 a 会立即销毁
- 由于产生了闭包，所以 fn1 函数中的变量 a 不会立即销毁，因为 fn2 函数还要继续调用变量 a
- 只有等所有函数把变量 a 调用完了，变量 a 才会销毁。
- 闭包的主要作用就是：延伸了变量的作用范围。
