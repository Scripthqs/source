# 模板引擎

开发模式：耦合式开发（前后端会黏在一起的开发模式）会需要用到模板引擎，模板引擎类似于提供了mvc中的v操作，在模板引擎中的模板中，会既有前端代码又有后端的代码。其最终的体现是一个html文件。

## 介绍

在一个web应用程序中，如果只是使用服务器端代码来编写客户端html代码，前后端不分离，那么会造成很大的工作量，而且写出来的代码会比较难以阅读和维护，如果只是使用客户端的静态的HTML文件，那么后端的逻辑也会比较难以融入到客户端的HTML代码中。为了维护方便，且使后端逻辑能够比较好的融入前端的HTML代码中，同时便于维护，很多第三方开发者就开发了各种Nodejs模板引擎，其中比较常用的就是jade/Pug，Ejs和art-template等模板引擎。

目的：使后端逻辑能够比较好的融入前端的HTML代码中，同时便于维护。

## art-template

art-tempalte是一个简约、特快的模板引擎。

特性：

- 拥有接近JS渲染（DOM操作）极限的性能
- 调试友好：语法，运行时错误日志准确到模板所在行，支持在模板文件上打断点（webpack Loader）
- 支持express，koa，webpack
- 支持模板的继承（布局）与子模板（引入包含）
- 浏览器版本仅6kb

## 安装与配置

在express项目中通过npm来安装

- `npm i -S art-template express-art-template`
- `app.engine('html',require('express-art-template))` 指定art-template模板，并指定模块后缀为html
- `app.set('views',path.join(_dirname,'view'))' 指定模板视图路径
- `app.set('view engine','html')` 省略指定模板文件后缀后名称（可选）

## 使用语法

视图需要使用数据，但是来源响应的的方法（后端），展示数据需要其特有的语法展示，不是前端的html语法，也不是js语法。

### 基本数据展示有两种写法

1. 标准写法：`{{变量名}}`
2. 原始写法：`<%=变量名%>`

### 数组

通过each标签进行展示，语法：

````html
{{each 变量}}
循环体
默认的key与value的变量名键是$index，值是$value，内置的一定需要加$符号
运行自己定义key和value变量名，自己定义的名字可以不用加$符号，如果自定义，则
//{{each 变量名 值 键}}
{{/each}}
````

### 判断

思路：先写原生的js代码，再转化。去掉原先的括号，再加2层括号

标准写法：

- `{{if}}{{/if}}`

原生的写法：

- `<%if(){%>`
- `<%}else if(){%>`
- `<%}%>`

### html代码解析

在默认情况下，HTML代码只会被原样输出，要想浏览器解析需要：

1. 标准写法：`{{@ 变量}}`
2. 原生写法：`<%- 变量 %>`

## 模板包含

在一个模板文件中引入另一个模板文件。为了方便复用

1. 标准写法：`{{include '被引入文件路径'}}`
2. 原生写法：`<% include('被引入文件路径') %>`

- 如果是当前路径，一定要写`./`，不写则从根目录下寻找
- 被include的文件后缀名默认是`.art`，如果不是不能省略
- 在子模板中，最好不要有html、head和body标签，否则容易出现样式错误

## 模板继承

模板继承又称模板布局，应用场景：主要应用在多个页面有重复布局的场景，例如上中下布局，一般上下是固定的，中间部分变化。

布局文件（父/公共页面）：

- `<title>{{block 'title'}}my site{{/block}}</title>`
- `{{block 'content'}}{{/block}}`block占位符 content此占位的名称

需要布局的文件（子/填坑）：

- `{{extend './父页面路径'}}`
- `{{block 'title'}}首页{{/block}}`
- `{{block 'content'}}<p>段落</p>{{/block}}`

